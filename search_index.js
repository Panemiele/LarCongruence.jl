var documenterSearchIndex = {"docs":
[{"location":"documentazioni/sparseMatrix/","page":"Sparse Matrix","title":"Sparse Matrix","text":"LarCongruence.cellCongruenceSM_OPT","category":"page"},{"location":"documentazioni/sparseMatrix/#LarCongruence.cellCongruenceSM_OPT","page":"Sparse Matrix","title":"LarCongruence.cellCongruenceSM_OPT","text":"cellCongruenceSM_OPT(cop, lo_cls, lo_sign)\n\nValuta la congruenza tra celle per una cocatena cop utilizzando le classi lo_cls, cioè la mappa che identifica per ciascun nuovo vertice calcolato identifica i vecchi vertici di partenza.\n\nLa funzione determina il nuovo operatore di cocatena costruito a partire da cop dove viene eseguito il merge delle celle di ordine inferiore secondo la mappa lo_cls. lo_sign specifica se una cella debba essere considerata nel verso opposto.\n\nSe il parametro opzionale imp vale true, allora le imprecizioni vengono tenute in considerazione nel senso che le celle di ordine inferiore potrebbero collidere. Il parametro d rappresenta, quindi l'ordine della cella (corrisponde anche al numero minimo di celle  di ordine inferiore di cui la cella corrente deve essere costituita).\n\nArgomenti\n\ncop::Lar.ChainOp\nlo_cls::Array{Array{Int,1},1}\nlo_sign::Array{Array{Int8,1},1}\nimp = false\nd = 0\n\nReturn\n\n(nrows, ho_cls, ho_sign)::Tuple{ Lar.ChainOp,  Array{Array{Int,1},1},  Array{Array{Int8,1},1} }\n\n\n\n\n\n","category":"function"},{"location":"documentazioni/sparseMatrix/","page":"Sparse Matrix","title":"Sparse Matrix","text":"LarCongruence.chainCongruenceSM_OPT","category":"page"},{"location":"documentazioni/sparseMatrix/#LarCongruence.chainCongruenceSM_OPT","page":"Sparse Matrix","title":"LarCongruence.chainCongruenceSM_OPT","text":"chainCongruenceSM_OPT(G, T)\n\nCalcola la congruenza della geometria G e coerentemente trasforma la topologia T\n\nArgomenti\n\nG::Lar.Points\nT::Array{Lar.ChainOp}\nimp=false\nϵ=1e-6\n\nReturn\n\n(G, Tn)::Tuple{Lar.Points, TnArray{Lar.ChainOp}}\n\n\n\n\n\n","category":"function"},{"location":"documentazioni/graphBLAS/","page":"GraphBLAS","title":"GraphBLAS","text":"LarCongruence.cellCongruence_OPT","category":"page"},{"location":"documentazioni/graphBLAS/#LarCongruence.cellCongruence_OPT","page":"GraphBLAS","title":"LarCongruence.cellCongruence_OPT","text":"cellCongruence_OPT(Delta, classes)\n\nValuta ed esegue la congruenza tra celle per una geometria (in graphBLAS) Delta utilizzando le classi `classes', cioè la mappa che identifica per ciascun nuovo vertice calcolato identifica i vecchi vertici di partenza.\n\nArgomenti\n\nDelta::GrB_Matrix{T}\nclasses::Array{Array{Int,1},1}\n\nReturn\n\n(res, eclasses)::Tuple{Matrix{Float64}, Vector{GrB_Matrix{Int8}}}\n\n\n\n\n\n","category":"function"},{"location":"documentazioni/graphBLAS/","page":"GraphBLAS","title":"GraphBLAS","text":"LarCongruence.chainCongruenceGB_OPT","category":"page"},{"location":"documentazioni/graphBLAS/#LarCongruence.chainCongruenceGB_OPT","page":"GraphBLAS","title":"LarCongruence.chainCongruenceGB_OPT","text":"chainCongruenceGB_OPT(W, Top)\n\nCalcola la congruenza della geometria W e coerentemente trasforma la topologia Top\n\nArgomenti\n\nW::Lar.Points\nTop::Vector{GrB_Matrix{Int8}}\n\nReturn\n\n(V, Topn)::Tuple{Lar.Points, TnArray{Lar.ChainOp}}\n\n\n\n\n\n","category":"function"},{"location":"esempi/#Esempi","page":"Esempi","title":"Esempi","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"In questa sezione, verranno mostrati diversi esempi per mostrare la correttezza degli input e degli output:","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Alcuni di questi esempi sono di dimensioni contenute, per introdurre il lettore in modo graduale;\nAltri esempi invece hanno dimensioni sufficientemente grandi da \"mettere in crisi\" un calcolatore con specifiche medie;\nAltri ancora sono più complessi e, oltre a mostrare la correttezza dell'output, mostrano l'effetto della funzione \"chainCongruence()\", la quale riduce le dimensioni delle matrici EV ed FV (la dimensione si riduce perché vengono rimossi vertici, facce e spigoli duplicati);","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"In questi esempi, sono mostrate anche le differenze tra una versione non ottimizzata di \"chainCongruence()\" ed una ottimizzata. E' stato usato in modo massiccio ViewerGL, così da poter verificare in modo visuale la correttezza dell'output generato.","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"tip: Link ai notebook\nQuesta pagina della documentazione descrive gli esempi utilizzati; tali esempi sono resi disponibili tramite questo link al repository: [CPD22-7a]Esempi.ipynb. Si consiglia caldamente di consultare tale notebook, in modo tale da poter lanciare gli esempi su un ambiente locale e anche di leggere passo passo le varie operazioni.","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"note: Nota\nLa funzione chainCongruence() utilizzata in questi esempi fa riferimento all'implementazione di Array of Arrays; verranno mostrati i confronti tra le varie implementazioni nella prossima sezione.","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"warning: Limiti di Space Arrangement\nLa funzione space_arrangement() usata negli esempi potrebbe impiegare davvero tanto tempo per input molto grandi e, probabilmente, entrerà in loop. Si consiglia, pertanto, di effettuare dei test sulla macchina utilizzata al fine di studiarne i range possibili.(Image: Edges-Vertices)","category":"page"},{"location":"esempi/#Global-Set-up","page":"Esempi","title":"Global Set up","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Prima di lanciare gli esempi, verrà preparato l'ambiente adatto: si importano le librerie necessarie al corretto funzionamento, quali: LinearAlgebraicRepresentation, LarCongruence, ViewerGL. Successivamente, vengono definite delle versioni modificate delle funzioni chainCongruence() e coboundary_1(): le modifiche apportate fanno si che entrambe le funzioni si comportino in modo adeguato su input di grandi dimensioni.","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Dopo il set up, si è pronti a lanciare gli esempi in tutta libertà.","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"using BenchmarkTools\nusing ViewerGL, LinearAlgebra\nusing LinearAlgebraicRepresentation\nusing NearestNeighbors, DataStructures, SparseArrays\nusing StatsAPI\nusing SparseMM\nusing LarCongruence\nusing Images\nusing Colors\nusing Plots\nusing Base.Threads\nusing SparseArrays\nusing DataStructures\nusing NearestNeighbors\nusing LinearAlgebra\nnthreads()","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Lar= LinearAlgebraicRepresentation;\nL = Lar;\nLC = LarCongruence;\nusing ViewerGL;\nGL = ViewerGL;","category":"page"},{"location":"esempi/#Chain-Congruence-Versioni-normale-e-modificata","page":"Esempi","title":"Chain Congruence - Versioni normale e modificata","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Prima di proseguire con gli esempi, verranno definite le funzioni utilizzate per calcolare la congruenza; in particolare, vengono proposte due versioni:","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"chainCongruenceAA(), versione normale della funzione, basata su Array of Arrays;\nchainCongruenceAA_OPT(), versione che sfrutta i tasks.","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"La funzione chainCongruenceAA() è stata modificata aggiungendo a cellCongruenceAA_OPT() l'utilizzo dei tasks, precisamente nel primo for: quì vengono scorse le classi di vertices (se viene chiamata cellCongruenceAA_OPT(T[1],vclasses) ) o di edges (se invece viene chiamata cellCongruenceAA(T[2],eclasses); la cardinalità di vclasses, per esempio, è pari al numero di vertici della geometria, perciò più grande questa è grande, maggiore è la necessità di rendere asincrona questa porzione di codice. ","category":"page"},{"location":"esempi/#Example-1-two-intersecting-cuboids-grid","page":"Esempi","title":"Example 1 - two intersecting cuboids grid","text":"","category":"section"},{"location":"esempi/#Grid-size:-3x3x3","page":"Esempi","title":"Grid size: 3x3x3","text":"","category":"section"},{"location":"esempi/#Cells-number:-27x2-54","page":"Esempi","title":"Cells number: 27x2 = 54","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Questo piccolo esempio è stato proposto per mostrare, innanzitutto, la corretta creazione delle griglie di input e la corretta visualizzazione dell'output. L'approccio seguito in questo esempio (la struttura dell'esempio stesso e l'utilizzo di ViewerGL) verrà riproposto anche nei successivi.","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Le due griglie, che differiscono leggermente di posizione e rotazione, sono intersecate fra loro e possiedono, in totale, un numero pari a 54 celle (27 per griglia). Data la traslazione e la rotazione di cui sopra, non è ancora possibile, in questo esempio, mostrare il comportamento della funzione chainCongruence(); tuttavia, rimane un buon esempio iniziale per comprendere il dominio applicativo. (Image: Edges-Vertices) (Image: Facets-Vertices) Per completare l'esempio e mostrare il pattern seguito nei vari esempi, vengono mostrati ulteriori dettagli grafici; questi permettono, in ordine, di mostrare:","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"vertici e facce della geometria numerati:","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"(Image: Numbering)","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"le facce della geometria:","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"(Image: Explode Facets)","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"gli spigoli della geometria:","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"(Image: Explode Edges)","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"la decomposizione della geometria:","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"(Image: Decomposition)","category":"page"},{"location":"esempi/#Example-2-two-adjacent-cubes-on-faces","page":"Esempi","title":"Example 2 - two adjacent cubes on faces","text":"","category":"section"},{"location":"esempi/#Cubes-number:-2","page":"Esempi","title":"Cubes number: 2","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Quest'altro piccolo esempio permette di osservare il comportamento della funzione chainCongruence() in modo molto semplice.","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"vengono creati due cubi adiacenti su una delle loro facce (verrà aggiunta una distanza di 0.0000001 tra un cubo ed un altro per evitare che la funzione cuboid() risolva la congruenza al posto della funzione chainCongruence());\ntali cubi sono creati in modo separato, perciò essi avranno i vertici e la faccia su cui risultano adiacenti duplicati;\ngodendo di queste caratteristiche, alla geometria può essere applicata la funzione chainCongruence() che fa si che i vertici e le facce duplicate vengano rimosse, mettendo \"a fattor comune\" vertici e facce su cui i cubi risultano adiacenti","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Essendo due cubi, ci si aspetta di passare, per quanto riguarda il numero di vertici distinti, da 16 a 12 mentre per le facce distinte ci si aspetta di passare da 12 (6 per cubo) a 8: questo perché 4 vertici + 1 faccia sono in comune tra i due cubi e, perciò, la funzione utilizzata rimuoverà tali copie. (Image: Edges-Vertices) (Image: Facets-Vertices)","category":"page"},{"location":"esempi/#Chain-Congruence-application","page":"Esempi","title":"Chain Congruence application","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Verrà ora dimostrato che la dimensione di EV ottenuto dopo la congruenza è minore rispetto a quello iniziale. Questo è dovuto al fatto che 4 vertici ed una faccia risultano duplicati e la funziona \"chainCongruence()\" li ha eliminati (come volevasi dimostrare: EV - EV_B = 24 - 20 = 4 vertici doppioni eliminati). La figura risultante, come si vede dall'immagine sottostante, è esattamente identica a quella iniziale, nonostante l'eliminazione dei vertici duplicati. (Image: After congruence) Anche in questo caso, vengono mostrati ulteriori dettagli grafici: (Image: Numbering) (Image: Explode Facets) (Image: Explode Edges) (Image: Decomposition)","category":"page"},{"location":"esempi/#Example-3-two-adjacent-cubes-on-the-edges","page":"Esempi","title":"Example 3 - two adjacent cubes on the edges","text":"","category":"section"},{"location":"esempi/#Cubes-number:-2-2","page":"Esempi","title":"Cubes number: 2","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Un altro esempio di dimensioni contenute; anche quì si osserva il comportamento della funzione chainCongruence().","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"vengono creati due cubi adiacenti su uno dei loro spigoli (verrà aggiunta una distanza di 0.0000001 tra un cubo ed un altro per evitare che la funzione cuboid() risolva la congruenza al posto della funzione chainCongruence());\ntali cubi sono creati in modo separato, perciò essi avranno lo spigolo su cui risultano adiacenti duplicato;\ngodendo di queste caratteristiche, alla geometria può essere applicata la funzione chainCongruence() che fa si che lo spigolo duplicato venga rimosso, mettendolo \"a fattor comune\".","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Essendo due cubi, ci si aspetta di passare, per quanto riguarda il numero di spigoli, da 24 a 23: questo perché lo spigolo è in comune tra i due cubi e, perciò, la funzione utilizzata rimuoverà una delle due copie. (Image: Edges-Vertices) (Image: Facets-Vertices)","category":"page"},{"location":"esempi/#Chain-Congruence-application-2","page":"Esempi","title":"Chain Congruence application","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Verrà ora dimostrato che la dimensione di EV ottenuto dopo la congruenza è minore rispetto a quello iniziale. Questo è dovuto al fatto che uno spigolo risulta duplicato e la funzione \"chainCongruence()\" lo ha eliminato (come volevasi dimostrare: EV - EV_B = 24 - 23 = 1 spigolo doppione eliminato). La figura risultante, come si vede dall'immagine sottostante, è esattamente identica a quella iniziale, nonostante l'eliminazione dello spigolo duplicato. (Image: After congruence) Come per gli altri esempi, vengono mostrati ulteriori dettagli grafici: (Image: Numbering) (Image: Explode Facets) (Image: Explode Edges) (Image: Decomposition)","category":"page"},{"location":"esempi/#Example-4-two-near-cubes","page":"Esempi","title":"Example 4 - two near cubes","text":"","category":"section"},{"location":"esempi/#Cubes-number:-2-3","page":"Esempi","title":"Cubes number: 2","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Quest'ultimo esempio di piccole dimensioni viene proposto per capire i limiti di applicazione della funzione chainCongruence().","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"vengono creati due cubi:\nLo spigolo di uno dei due giace su una delle facce dell'altro\ntali cubi sono creati in modo separato, perciò essi saranno composti da vertici, facce e spigoli distinti;\ngodendo di queste caratteristiche, alla geometria può essere applicata la funzione chainCongruence(), MA essa non avrà alcun effetto: infatti, dato che non ci sono vertici, facce o spigoli in comune tra i due cubi, non esistono duplicati di essi, quindi la funzione non rimuoverà nulla.","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"(Image: Edges-Vertices) (Image: Facets-Vertices)","category":"page"},{"location":"esempi/#Chain-Congruence-application-3","page":"Esempi","title":"Chain Congruence application","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Verrà ora dimostrato che la dimensione di EV ottenuto dopo la congruenza è uguale a quella iniziale. Questo è dovuto al fatto che non ci sono vertici, facce o spigoli duplicati e quindi la funzione \"chainCongruence()\" non ha modificato nulla. Nonostante ciò, la figura risultante è la stessa. (Image: After congruence) Come per gli altri esempi, vengono mostrati ulteriori dettagli grafici: (Image: Numbering) (Image: Explode Facets) (Image: Explode Edges) (Image: Decomposition)","category":"page"},{"location":"esempi/#Example-5-Grid-inside-another-grid","page":"Esempi","title":"Example 5 - Grid inside another grid","text":"","category":"section"},{"location":"esempi/#Small-Grid:-3x3x3","page":"Esempi","title":"Small Grid: 3x3x3","text":"","category":"section"},{"location":"esempi/#Big-grid:-5x5x5","page":"Esempi","title":"Big grid: 5x5x5","text":"","category":"section"},{"location":"esempi/#Cells-number:-27-125-134","page":"Esempi","title":"Cells number: 27 + 125 = 134","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Riprendendo l'esempio precedente sulle griglie (il numero 1), ne verranno ora mostrate due di diverse dimensioni, con la più grande sovrapposta alla prima (le due griglie sono perfettamente congruenti sulle celle della più piccola tra le due). L'obiettivo di questo esempio è mostrare come, applicando ***chainCongruence()***, sia possibile ridurre notevolmente il numero di vertici, facce e spigoli inizialmente creati, eliminando i doppioni; questa azione è necessaria perché le celle della griglia più piccola sono duplicate (la griglia più grande contiene celle nelle stesse identiche posizioni della più piccola, quindi vertici, spigoli e facce sono duplicate) (Image: Edges-Vertices) (Image: Facets-Vertices)","category":"page"},{"location":"esempi/#Chain-Congruence-application-4","page":"Esempi","title":"Chain Congruence application","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Verrà ora dimostrato che la dimensione di EV ottenuto dopo la congruenza è minore rispetto a quello iniziale. Questo è dovuto al fatto che molti vertici risultano duplicati e la funziona \"chainCongruence()\" li ha eliminati (in particolare: EVA - EVB = 684 - 540 = 144 vertici doppioni eliminati). La figura risultante, come si vede dall'immagine sottostante, è esattamente identica a quella iniziale, nonostante l'eliminazione dei vertici duplicati. (Image: After congruence) Come per gli altri esempi, vengono mostrati ulteriori dettagli grafici: (Image: Numbering) (Image: Explode Facets) (Image: Explode Edges) (Image: Decomposition)","category":"page"},{"location":"esempi/#Example-6-Grid-inside-another-grid-(BIG)","page":"Esempi","title":"Example 6 - Grid inside another grid (BIG)","text":"","category":"section"},{"location":"esempi/#Small-Grid:-10x10x10","page":"Esempi","title":"Small Grid: 10x10x10","text":"","category":"section"},{"location":"esempi/#Big-grid:-15x15x15","page":"Esempi","title":"Big grid: 15x15x15","text":"","category":"section"},{"location":"esempi/#Cells-number:-1000-3375-4375","page":"Esempi","title":"Cells number: 1000 + 3375  = 4375","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Viene replicato l'esempio precedente, ma con dimensioni delle griglie decisamente più grandi (4375 celle contro le 134 dell'esempio precedente). L'obiettivo è quello di spingere il calcolatore ad effettuare calcoli di grande portata, mettendolo in difficoltà. Anche quì, verrà dimostrata la correttezza dell'output, sia della funzione chainCongruence(), sia delle funzioni per la presentazione grafica di ViewerGL. (Image: Edges-Vertices) (Image: Facets-Vertices)","category":"page"},{"location":"esempi/#Chain-Congruence-application-5","page":"Esempi","title":"Chain Congruence application","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Verrà ora dimostrato che la dimensione di EV ottenuto dopo la congruenza è minore rispetto a quello iniziale. Questo è dovuto al fatto che molti spigoli risultano duplicati e la funziona \"chainCongruence()\" li ha eliminati (in particolare: EVA - EVB = 15150 - 11520 = 3630 vertici doppioni eliminati). Come si può vedere, la griglia ottenuta è identica a quella di partenza, ma i vertici utilizzati per la sua creazione sono in numero minore. (Image: After congruence) Come per gli altri esempi, vengono mostrati ulteriori dettagli grafici: (Image: Numbering) (Image: Explode Facets) (Image: Explode Edges) (Image: Decomposition)","category":"page"},{"location":"esempi/#Example-7-100x50-cuboids-table","page":"Esempi","title":"Example 7 - 100x50 cuboids table","text":"","category":"section"},{"location":"esempi/#Cells-number:-100x50-5000","page":"Esempi","title":"Cells number: 100x50 = 5000","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Questo esempio è stato pensato per testare le performance della funzione chainCongruence() nella sua versione normale e quella che sfrutta i tasks: ci si aspetterebbe un miglioramento nella seconda versione poiché questa presenta una piccola porzione di codice che lavora in modo asincrono; tale porzione, però, viene richiamata un numero di volte elevato, pari al numero di vertici nella geometria, ed essendo questa geometria molto vasta (il numero di vertici è alto), i benefici previsti dovrebbero essere alti (o quantomeno presenti). Il miglioramento sulla seconda versione, però, non si verifica: questo è dovuto alla semplicità della porzione di codice chiamata; seppur essa sia chiamata un numero di volte elevato, essendo molto semplice, risulta più complesso utilizzare la programmazione asincrona (e quindi i tasks) piuttosto che lavorare in modo seriale; perciò, la versione normale di chainCongruence() è preferibile. (Image: Edges-Vertices) (Image: Facets-Vertices)","category":"page"},{"location":"esempi/#Confronto-fra-chainCongruence()-normale-e-modificata","page":"Esempi","title":"Confronto fra chainCongruence() normale e modificata","text":"","category":"section"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Come anticipato nella presentazione dell'esempio, ci si aspetterebbe un miglioramento, ma per via della semplicità della porzione di codice chiamata, risulta preferibile la versione normale. Tra l'altro, anche l'utilizzo di memoria è migliore nella versione normale: si passa da 60.38 MiB della versione normale a 75.98 MiB di quella modificata coi tasks; questo è dovuto alla porzione asincrona che richiede più risorse in parallelo. (Image: After congruence)","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Versione normale:","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"(Image: chainCongruence() Normale)","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Versione modificata:","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"(Image: chainCongruence() Modificata)","category":"page"},{"location":"esempi/","page":"Esempi","title":"Esempi","text":"Come per gli altri esempi, vengono mostrati ulteriori dettagli grafici: (Image: Numbering) (Image: Explode Facets) (Image: Explode Edges) (Image: Decomposition)","category":"page"},{"location":"risultati/#Confronto-versioni-\"chainCongruence()-tra-le-varie-implementazioni\"","page":"Risultati e prestazioni","title":"Confronto versioni \"chainCongruence() tra le varie implementazioni\"","text":"","category":"section"},{"location":"risultati/","page":"Risultati e prestazioni","title":"Risultati e prestazioni","text":"Sono stati utilizzati tre esempi, tutti diversi tra loro in quanto a dimensioni dell'input, in modo da poter verificare i cambiamenti di comportamento delle funzioni al loro variare. Ci si aspetta dunque un miglioramento più evidente sugli esempi di dimensioni maggiore, questo perché eseguire operazioni complesse come quelle utilizzate per la programmazione asincrona e/o parallela, su input di piccole dimensioni, in modo controintuitivo, può penalizzare le prestazioni, cosa che non accade per input più grandi.","category":"page"},{"location":"risultati/","page":"Risultati e prestazioni","title":"Risultati e prestazioni","text":"Esempio 1 - input 3x24\nEsempio 2 - input 3x432\nEsempio 3 - input 1192x3","category":"page"},{"location":"risultati/","page":"Risultati e prestazioni","title":"Risultati e prestazioni","text":"La funzione testata e di cui si mostrano i confronti tra i diversi risultati nelle sezioni seguenti è \"chainCongruence()\", nelle sue diverse versioni SM, GB, AA, eseguendo il confronto di ciascuna tra la versione originale del codice e quella ottimizzata introducento la parallelizzazione.","category":"page"},{"location":"risultati/","page":"Risultati e prestazioni","title":"Risultati e prestazioni","text":"Per la valutazione delle prestazioni è stata utilizzata la macro julia @benchmark, presente all'interno del package BenchmarkTools.jl, la quale va a eseguire la funzione testata un certo numero di volte, restituendo tempo medio di esecuzione (espresso in millisecondi o microsecondi) e lo spazio medio allocato (espresso in Mebibyte o Kibibyte), nei grafici seguenti vengono mostrati i tempi medi di esecuzione.","category":"page"},{"location":"risultati/#Julia-Native-Sparse-Matrix","page":"Risultati e prestazioni","title":"Julia Native Sparse Matrix","text":"","category":"section"},{"location":"risultati/","page":"Risultati e prestazioni","title":"Risultati e prestazioni","text":"L'implementazione SM non ha mostrato grandi miglioramenti; come detto in precedenza le differenze sono più evidenti nel terzo esempio in quanto è quello che presenta input di dimensioni maggiori. In questo esempio infatti si ha un miglioramento sui tempi di esecuzione di circa il 6%. (Image: SM graph) ","category":"page"},{"location":"risultati/#GraphBLAS","page":"Risultati e prestazioni","title":"GraphBLAS","text":"","category":"section"},{"location":"risultati/","page":"Risultati e prestazioni","title":"Risultati e prestazioni","text":"L'implementazione GB è stata quella che ha risposto meglio alle modifiche, con evidenti miglioramenti in tutti gli esempi testati. Si nota infatti un netto miglioramento del 65% sui tempi di esecuzione, questo perché la funzione 'cellCongruence()' dell'implementazione GB si presta bene all'utilizzo dei threads. (Image: GB graph) ","category":"page"},{"location":"risultati/#Array-of-Arrays","page":"Risultati e prestazioni","title":"Array of Arrays","text":"","category":"section"},{"location":"risultati/","page":"Risultati e prestazioni","title":"Risultati e prestazioni","text":"Anche l'implementazione AA ha ottenuto buoni risultati dopo le modifiche, si nota un miglioramento di quasi il 20% sui tempi di esecuzione del primo esempio e uno di circa il 5% sul terzo. (Image: AA graph)","category":"page"},{"location":"grafoDipendenze/#Grafo-delle-dipendenze-originale","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze originale","text":"","category":"section"},{"location":"grafoDipendenze/","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze","text":"In questa sezione è rappresentato il grafo orientato delle dipendenze. Ogni arco orientato rappresenta una chiamata di funzione (v_1 v_2), dove v_1 è la funzione chiamante, e v_2 è la funzione chiamata. I nodi hanno un’etichetta corrispondente al nome del package mentre gli archi hanno un elenco di etichette corrispondenti alle coppie (v_1 v_2) precedentemente descritte.","category":"page"},{"location":"grafoDipendenze/","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze","text":"(Image: Grafo delle dipendenze)","category":"page"},{"location":"grafoDipendenze/#Come-realizzare-il-grafo","page":"Grafo delle dipendenze","title":"Come realizzare il grafo","text":"","category":"section"},{"location":"grafoDipendenze/","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze","text":"Per quanto riguarda la costruzione del grafo, è stato utilizzato il package \" PkgDependency.jl \", il quale permette di ricavare tutte le dipendenze di un package e le va a mostrare sotto forma di albero. Successivamente, utilizzando le informazioni ottenute tramite il package, è stato creato il grafo sulla piattaforma online \" diagrams.net\", precedentemente nota come \"draw.io\".","category":"page"},{"location":"documentazioni/verticesCongruence/#Vertices-Congruence","page":"Vertices Congruence","title":"Vertices Congruence","text":"","category":"section"},{"location":"documentazioni/verticesCongruence/","page":"Vertices Congruence","title":"Vertices Congruence","text":"LarCongruence.vertCongruenceOptimized","category":"page"},{"location":"documentazioni/verticesCongruence/#LarCongruence.vertCongruenceOptimized","page":"Vertices Congruence","title":"LarCongruence.vertCongruenceOptimized","text":"vertCongruenceOptimized(V)\n\nValuta ed esegue la congruenza di vertici per punti 3D V  ℳ(3n).\n\nLa funzione determina i punti di V più vicini di ϵ e costruisce un nuovo insieme di vertici costituito dal rappresentativo per ciascun cluster di punti. Per fare ciò si utilizza l'algoritmo KDTree fornito dal package NearestNeighbors.\n\nIl metodo restituisce:\n\nil nuovo insieme di vertici\nuna mappa che, per ogni nuovo vertice, identifica i vecchi vertici nell'insieme di partenza\n\nArgomenti\n\n'V::Lar.Array{Float64,2}'\n'ϵ=1e-6'\n\nReturn\n\n(V, Vcls)::Tuple{Lar.Points, Array{Array{Int,1},1}}\n\n\n\n\n\n","category":"function"},{"location":"documentazioni/verticesCongruence/","page":"Vertices Congruence","title":"Vertices Congruence","text":"err = 1e-8\nV = [\n    0.0  err  0.0 -err  0.0  0.0\n    0.0  0.0  err  0.0 -err  0.0\n]\n\nLC.vertCongruenceOptimized(V[:, 1:5])\n\nLC.vertCongruenceOptimized(V[:, 2:6])","category":"page"},{"location":"documentazioni/verticesCongruence/#Variante-per-implementazione-AA","page":"Vertices Congruence","title":"Variante per implementazione AA","text":"","category":"section"},{"location":"documentazioni/verticesCongruence/","page":"Vertices Congruence","title":"Vertices Congruence","text":"LarCongruence.vertCongruenceAA_OPT","category":"page"},{"location":"documentazioni/verticesCongruence/#LarCongruence.vertCongruenceAA_OPT","page":"Vertices Congruence","title":"LarCongruence.vertCongruenceAA_OPT","text":"vertCongruenceAA_OPT(W)\n\nValuta ed esegue la congruenza di vertici per punti 3D W  ℳ(3n).\n\nLa funzione determina i punti di W più vicini di err (definito all'interno della funzione, valore pari a 10^-6) e costruisce un nuovo insieme di vertici costituito dal rappresentativo  per ciascun cluster di punti. Per fare ciò si utilizza l'algoritmo KDTree fornito dal package  NearestNeighbors.\n\nIl metodo restituisce:\n\nil nuovo insieme di vertici\nuna mappa che, per ogni nuovo vertice, identifica i vecchi vertici nell'insieme di partenza\n\nArgomenti\n\n'V::Lar.Array{Float64,2}'\n\nReturn\n\n(V, vclasses)::Tuple{Lar.Points, Array{Array{Int,1},1}}\n\n\n\n\n\n","category":"function"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"In questa sezione, verranno introdotti i principali concetti matematici e tecnologici utilizzati all'interno del progetto LarCongruence.jl.","category":"page"},{"location":"theory/#Matrici-Sparse","page":"Introduzione","title":"Matrici Sparse","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"In analisi numerica, una matrice sparsa è una matrice i cui valori sono quasi tutti uguali a zero. I pochi valori presenti sono distribuiti in modo casuale, cioè non si concentrano in determinate aree specifiche (Cluster).","category":"page"},{"location":"theory/#Semiring","page":"Introduzione","title":"Semiring","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Un Semiring è una struttura algebrica che generalizza l'aritmetica reale rimpiazzando (+,·) con l'operazione binaria (Op1, Op2). Un Semiring, in GraphBLAS, viene definito come l'unione di un monoide M e un operatore binario moltiplicativo F};","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Il monoide è una struttura algebrica formata da un operatore binario associativo e commutativo di tipo additivo} e da un dominio D che deve contenere anche un elemento vuoto (simbolo dell'operatore: ⊕);\nL'operatore binario F è formato invece da due domini di input e un dominio di output (simbolo dell'operatore: ⊗).","category":"page"},{"location":"theory/#GraphBLAS","page":"Introduzione","title":"GraphBLAS","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"GraphBLAS è la libreria che offre funzioni per matrici sparse, la più comune quando si parla di calcolo parallelo e distribuito. Questa libreria offre metodi smart ed efficaci per memorizzare valori ed effettuare operazioni su di essi all'interno di matrici sparse. Si può scegliere di implementare GraphBLAS sia sulla CPU che su GPU (la cosa interessante delle GPU è che lo si può fare in parallelo). Si usano le matrici per rappresentare i grafi, in modo da poter utilizzare le operazioni dell'algebra lineare che sono molto veloci da eseguire: il prodotto fra matrici, per esempio, permette di ricavare informazioni sui percorsi possibili e nodi vicini. GraphBLAS utilizza oggetti matematici chiamati \"Semirings\" che permettono di implementare qualsiasi operatore matematico e definire così un nuovo modello di prodotto matriciale. Due esempi:","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Plus-times: tipico prodotto matriciale\nTropical Semiring: usa i seguenti operatori:\ninterno: la somma\nesterno: il valore minimo","category":"page"},{"location":"theory/#Lar-Congruence","page":"Introduzione","title":"Lar Congruence","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"E' una libreria che ha l'obiettivo di eseguire la congruenza di celle e complessi di catene locali. Sono disponibili tre implementazioni di LarCongruence:","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Julia Native Sparse Matrix\nArray of Arrays\nGraphBLAS - estende il funzionamento di GraphBLAS, oltre che ai grafi, anche ai complessi cellulari.","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Per calcolare la congruenza di complessi di catena locali si procede come segue: ","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Per ogni faccia, si costruisce il suo complesso di catene locale, cioè la partizione del piano bidimensionale (identificato con z=0) indotta dal bordo di quella faccia e da tutte le altre che la dividono. \nSi rimette assieme per calcolare la congruenza: dall'insieme di complessi di catene locali ad ognuna delle facce dell'input, bisogna arrivare ad un unico complesso, \"incollando\" fra loro in modo coerente i vari complessi locali.","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Si noti che l'operazione che può essere parallelizzata è la prima, questo perché viene eseguita in modo indipendente per ciascuna delle facce.","category":"page"},{"location":"theory/#SIMD","page":"Introduzione","title":"SIMD","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Single Instruction, Multiple Data (SIMD) è un metodo per parallelizzare i calcoli all'interno della CPU, per cui una singola operazione viene eseguita su più elementi di dati contemporaneamente. Le moderne architetture della CPU contengono set di istruzioni che possono farlo, operando su molti variabili contemporaneamente. Questo non rende ogni ciclo più veloce. In particolare, si noti che l'utilizzo di SIMD implica che l'ordine delle operazioni all'interno e attraverso il ciclo potrebbe cambiare. Il compilatore deve essere certo che il riordino sia sicuro prima che tenti di parallelizzare un ciclo","category":"page"},{"location":"theory/#Tasks","page":"Introduzione","title":"Tasks","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Un Task è semplicemente un insieme di istruzioni che possono essere sospese e riprese in qualsiasi momento all'interno di quell'insieme. Una funzione può anche essere pensata come un insieme di istruzioni, e quindi di attività può essere visto come qualcosa di simile. Ma ci sono due differenze fondamentali:","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Non c'è overhead per passare da un Task all'altro, il che significa che non viene riservato spazio nello stack per un cambio;\na differenza di una funzione che deve terminare prima che il controllo torni al chiamante, un Task può essere interrotto e il controllo può essere passato a un altro Task in molti momenti diversi durante la sua esecuzione. In altre parole, nelle attività non esiste una relazione gerarchica chiamante-chiamato. Questo da l'impressione di lavorare in parallelo.","category":"page"},{"location":"theory/#Threads","page":"Introduzione","title":"Threads","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"I Thread sono sequenze di calcolo che possono essere eseguite indipendentemente su un core della CPU, contemporaneamente ad altre sequenze simili. A differenza dei task, che sono leggeri, i thread devono memorizzare uno stato quando vengono scambiati. Così, mentre si possono avere centinaia o migliaia di task in esecuzione, è opportuno avere solamente un numero limitato di Thread, tipicamente pari al numero di core della macchina in uso.","category":"page"},{"location":"authors/#A-Autori","page":"Autori","title":"A - Autori","text":"","category":"section"},{"location":"authors/","page":"Autori","title":"Autori","text":"Questo repository è stato creato, curato e mantenuto da Gabriele Romualdi e Simone Chilosi, studenti del corso magistrale in Ingegneria Informatica presso l'Università degli Studi di Roma Tre.","category":"page"},{"location":"authors/#[Gabriele-Romualdi](https://github.com/Panemiele)","page":"Autori","title":"Gabriele Romualdi","text":"","category":"section"},{"location":"authors/","page":"Autori","title":"Autori","text":"Github\nLinkedin","category":"page"},{"location":"authors/#[Simone-Chilosi](https://github.com/simochilo)","page":"Autori","title":"Simone Chilosi","text":"","category":"section"},{"location":"authors/","page":"Autori","title":"Autori","text":"Github\nLinkedin","category":"page"},{"location":"documentazioni/arrayOfArrays/","page":"Array of Arrays","title":"Array of Arrays","text":"LarCongruence.cellCongruenceAA_OPT","category":"page"},{"location":"documentazioni/arrayOfArrays/#LarCongruence.cellCongruenceAA_OPT","page":"Array of Arrays","title":"LarCongruence.cellCongruenceAA_OPT","text":"cellCongruenceAA_OPT(Delta, inclasses)\n\nValuta la congruenza tra celle per una parte di topologia Delta utilizzando le classi inclasses, cioè la mappa che identifica per ciascun nuovo vertice calcolato i vecchi vertici di partenza,  oppure la mappa che identifica per ciascun nuovo bordo calcolato i vecchi bordi di partenza.\n\nLa funzione restituisce: \t- la matrice che rappresenta i nuovi bordi calcolati e la mappa che li lega ai bordi di partenza  \t  se in input viene passato un insieme di vertici e la mappa che li lega ai vertici di partenza. \t- la matrice che rappresenta le nuove facce calcolate e la mappa che le lega alle facce di partenza \t  se in input viene passato un insieme di bordi e la mappa che li lega ai bordi di partenza.\n\nArgomenti\n\nDelta::SparseMatrixCSC{Int8, Int64}\ninclasses::Vector{Any}\n\nReturn\n\n(FEnew, outclasses)::Tuple{ Vector{Vector{Int64}},  Vector{Vector{Int64}}}\n\n\n\n\n\n","category":"function"},{"location":"documentazioni/arrayOfArrays/","page":"Array of Arrays","title":"Array of Arrays","text":"LarCongruence.chainCongruenceAA_OPT","category":"page"},{"location":"documentazioni/arrayOfArrays/#LarCongruence.chainCongruenceAA_OPT","page":"Array of Arrays","title":"LarCongruence.chainCongruenceAA_OPT","text":"chainCongruenceAA_OPT(W, T)\n\nCalcola la congruenza della geometria W e coerentemente trasforma la topologia T La funzione restituisce tra matrici di incidenza/adiacenza: \t- V (il nuovo insieme di vertici calcolato con vertCongruenceAAOPT) \t- EV (matrice di adiacenza bordi/vertici, calcolata con cellCongruenceOPT utilizzando vclasses) \t- FE (matrice di adiacenza facce/bordi, calcolata con cellCongruence_OPT utilizzando eclasses)\n\nArgomenti\n\nW::Lar.Points\nT::Vector{SparseMatrixCSC{Int8, Int64}}\n\nReturn\n\n(V, EV, FE)::Tuple{Lar.Points, Vector{Vector{Int64}}, Vector{Vector{Int64}}}\n\n\n\n\n\n","category":"function"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"In questa sezione, verranno discussi gli step seguiti durante l'avanzamento del progetto.","category":"page"},{"location":"sviluppo/#Studio-preliminare","page":"Sviluppo","title":"Studio preliminare","text":"","category":"section"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"In questa prima fase, gli sforzi sono stati concentrati sullo studio della teoria di base legata intrinsecamente al progetto:","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Accezioni e nomenclature matematiche (es: monoidi, semirings, matrici sparse, ...)\nStudio delle strutture algebriche (es: celle, catene, cocatene, ...)\nStudio del linguaggio Julia (sintassi, funzioni, macro, ...)\nConcetti base sul funzionamento di GraphBLAS e funzioni Julia (SuiteSparseGraphBLAS e GraphBLASInterface)\nConcetti base sul funzionamento di Local Congruence (Sparse Matrix, Array of Arrays e GraphBLAS stesso)","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Inoltre, ci si è concentrati sulla realizzazione di un buon grafo delle dipendenze.","category":"page"},{"location":"sviluppo/#Studio-esecutivo","page":"Sviluppo","title":"Studio esecutivo","text":"","category":"section"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Il secondo step racchiude il modo in cui sono stati modificate le funzioni dei progetti cea-SM.jl e cea-GB.jl, in modo tale da introdurre un buon grado di parallelismo e migliorare le prestazioni. Per fare ciò, sono state utilizzate le funzioni e le macro offerte da Julia che permettono di operare in modo parallelo tramite semplice annotazioni; i concetti chiave utilizzati sono:","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Threads\nTasks\nSimd","category":"page"},{"location":"sviluppo/#Modifiche-effettuate","page":"Sviluppo","title":"Modifiche effettuate","text":"","category":"section"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Ci si è concentrati sul migliorare la funzione \"CellCongruence()\" in entrambe le implementazioni (SM e GB): questa funzione ha l’obiettivo di verificare ed eseguire la congruenza di celle e complessi di celle tra la geometria e la topologia passate in input. Poiché questo processo può essere eseguito in modo indipendente faccia per faccia, risulta opportuno parallelizzare la funzione tramite le macro fornite da Julia. A tale scopo, sono state attuate le seguenti modifiche:","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Vertices Congruence: la funzione vertCongruence (dal file verticesCongruence.jl) `e stata modifica in vertCongruenceOptimized (nel file verticesCongruence-optimized.jl), aggiungendo l’utilizzo dei Tasks.","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"@sync for vidx = 1 : size(V, 2)\n    @async begin\n        if !(vidx in visited)\n            nearvs = NearestNeighbors.inrange(kdtree, V[:, vidx], ϵ)\n            push!(Vcls, nearvs)\n            push!(visited, nearvs...)\n        end\n    end\nend","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Sparse Matrix: \nla funzione chainCongruenceSM OPT(...) è stata migliorata sfruttando i Tasks;\nla funzione cellCongruenceSM OPT(...) è stata migliorata sfruttando i Tasks e SIMD.","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"# chainCongruenceSM_OPT\n@sync for d = 1 : length(T)\n    @async Tn[d], cls, sign = cellCongruenceSM_OPT(T[d], cls, sign; imp=imp, d=d)\nend\n\n\n# cellCongruenceSM_OPT\n...\n@simd for i = 1 : length(lo_cls)\n    col = sum([\n        cop[:, lo_cls[i][j]] .* lo_sign[i][j]\n        for j = 1 : length(lo_cls[i])\n    ])\n    push!(copCols, col)\nend\n...\n@sync for row = 1 : cop.m\n    if rows[row].nzval[1] > 0\n        @async begin\n            rows[row] = -rows[row]\n            sign[row] = -1\n        end \n    end\nend\n...\n@simd for cidx = 1 : cop.m\n    if rows[rows_ord[cidx]] != nrows[nidx]  \n        nidx = nidx + 1;\n    end\n    push!(ho_cls[nidx], rows_ord[cidx])\nend\n...","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"GraphBLAS: Per quanto riguarda GraphBLAS, è stato scelto di implementare una sola modifica, per non penalizzare le performance: sono stati usati i Thread (in particolare 6, siccome la macchina utilizzata dispone di una CPU con 6 core) per eseguire la funzione cellCongruence_OPT(...)","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"@threads for i in eachindex(Topn)\n\tTopn[i], cls = cellCongruence_OPT(Top[i], cls)\nend","category":"page"},{"location":"sviluppo/#Studio-definitivo","page":"Sviluppo","title":"Studio definitivo","text":"","category":"section"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Per lo studio definitivo sono state apportate diverse modifiche:","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Innanzitutto, è stato modificato il file ce-AA.jl per migliorare i tempi di esecuzione delle funzioni dell'implementazione Array of Arrays, seguendo lo stesso approccio utilizzato durante lo studio esecutivo (macro julia @async, @sync)","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"# vertCongruenceAA_OPT\nfor vi in 1:size(verts,2)\n\t@async begin \n\t\tif !(vi in todelete)\n\t\t\tnearvs = NearestNeighbors.inrange(kdtree, verts[:,vi], err)\n\t\t\tpush!(vclasses,nearvs)\n\t\t\tnewverts[nearvs] .= i\n\t\t\tnearvs = setdiff(nearvs, vi)\n\t\t\ttodelete = union(todelete, nearvs)\n\t\t\ti += 1\n\t\tend\n\tend\nend\n...\nfor (k,class) in enumerate(vclasses)\n\t@async V[:,k] = sum(W[class,:],dims=1)/length(class)\nend\n...\n\n# cellCongruenceAA_OPT\n...\nfor (k,class) in enumerate(inclasses)\n\t@async for e in class\n\t\tnew_e[e] = k\n\tend\nend\n...\n@sync for (k,face) in enumerate(cells)\n    @async begin\n        if outclasses[face] == []\n            outclasses[face] = [k]\n        else\n            append!(outclasses[face],[k])\n        end\n    end\nend","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Sono stati successivamente studiati i package Images.jl e Plots.jl, utili per visualizzare graficamente matrici e matrici sparse, in modo da poter confrontare in modo visuale e in breve tempo gli output ottenuti tra le diverse versioni delle funzioni, così da poter verificare la loro correttezza. Le funzioni utilizzate per fare ciò sono state 'colorview' del package Images e 'spy' del package Plots.\nÈ stato aggiunto un nuovo esempio sfruttando la funzione randomcubes() presente all'interno del package LinearAlgebraicRepresentation.jl (LAR): tramite questa funzione è possibile generare dei cubi, in numero e dimensioni arbitrari, utilizzabili in esempi dinamici, poichè generati a runtime. Questo esempio risulta essere molto utile in quanto le dimensioni dell'input sono sufficientemente alte da poter verificare correttamente i miglioramenti di performance delle modifiche del codice (miglioramenti effettivamente ottenuti commentati in una prossima sezione della documentazione).\nSono state generate le nove matrici di incidenza/adiacenza descritte nel paper \"LAR-CAD2014-main\" (Image: Nove Matrici)  ","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Ciò è stato fatto a partire dal risultato della funzione 'randomcubes', ottenendo le matrici EV e FV e l'array dei vertici V; prese queste, è possibile ricavare tramite prodotto matriciale le seguenti sei matrici: VV, VE, EE, FE, EF, VF, FF. Il procedimento viene mostrato all'interno del notebook [CPD22-7a]adjacencyMatrices.ipynb","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Molte funzioni in diverse implementazioni mancavano di opportune docstring; esse sono state quindi aggiunte per garantire maggiore leggibilità.","category":"page"},{"location":"sviluppo/#Riferimenti","page":"Sviluppo","title":"Riferimenti","text":"","category":"section"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Per consultare il codice, si rimanda al link del repository GitHub, mentre per uno studio approfondito delle varie macro di Julia sopracitate, verranno elencati i vari link della documentazione:","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Threads\nTasks\nSIMD","category":"page"},{"location":"graph_blas/#Introduction-to-GraphBLAS-Framework","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"","category":"section"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"GraphBLAS is an API that defines a set of sparse matrix operation based on an algebra of semirings and designed to do computation on graphs.","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"Local congruence of Chain Complexes extends GraphBLAS domain from graphs to cellular complexes.","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"An interface to SuiteSparse:GraphBLAS C library for Julia is provided by two library: SuiteSparseGraphBLAS.jl and GraphBLASInterface.jl.","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"Each GraphBLAS function operates on a semiring S = langle D_out D_in1 D_in2 bigoplus bigotimes 0 rangle, defined by three domains D_out D_in1 D_in2, two binary operators, a commutative and an associative additive operation bigoplus  D_out times D_out rightarrow D_out and a multiplicative operation bigotimes  D_in1 times D_in2 rightarrow D_out, and an identity element 0 in D_out, that satisfies the following two conditions in their respective domains:","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"Additive identity: a bigoplus 0 = a\nMultiplicative annihilation: a bigotimes 0 = 0","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"A single domain D, together with an associative operation bigodot  D times D rightarrow D and an identity element 0 in D define a GraphBLAS monoid.","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"It is possible to create a monoid with a binary operator and an identity value, and a semiring with a monoid and a binary operator, respectively with GrB_Monoid_new(monoid, binary_op, identity) and GrB_Semiring_new(semiring, monoid, binary_op).","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"With monoid and semirings, in GraphBLAS you can override the normal plus and times operators in matrices multiplications, performed with GrB_mxm, in order to define complex algorithm in the language of linear algebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Progetto LAR Congruence per il corso di Calcolo Parallelo e Distribuito svolto da:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Nome Matricola E-mail Profilo Github\nGabriele Romualdi 521111 gab.romualdi@stud.uniroma3.it https://github.com/Panemiele\nSimone Chilosi 522155 sim.chilosi@stud.uniroma3.it https://github.com/simochilo","category":"page"},{"location":"","page":"Home","title":"Home","text":"Link al repository GitHub: https://github.com/Panemiele/LarCongruence.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Link ai notebook:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Array Of Arrays: https://github.com/Panemiele/LarCongruence.jl/examples/notebooks/[CPD22-7a]notebook_ArrayOfArrays.ipynb\nGraphBLAS: https://github.com/Panemiele/LarCongruence.jl/examples/notebooks/[CPD22-7a]notebook_GraphBLAS.ipynb\nJulia Native Sparse Matrix: https://github.com/Panemiele/LarCongruence.jl/examples/notebooks/[CPD22-7a]notebook_JuliaNativeSparseMatrix.ipynb","category":"page"},{"location":"#LarCongruence.jl","page":"Home","title":"LarCongruence.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LarCongruence.jl è una libreria Julia che fornisce strumenti per gestire congruenze locali di complessi di catene.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In particolare, dato un insieme di complessi di catene locali secondo gli standard LinearAlgebraicRepresentation, questo modulo Julia calcola il singolo complesso globale corrispondente usando la epsilon-congruenza delle celle, risolvendo topologicamente le inesattezze numeriche dell'aritmetica dei floating-point.","category":"page"},{"location":"#Dipendenze","page":"Home","title":"Dipendenze","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LarCongruence.jl utilizza alcune dipendenze, di seguito elencate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"DataStructures.jl\nGraphBLASInterface.jl\nLinearAlgebraicRepresentation\nNearestNeighbors.jl\nSparseArrays.jl\nSparseMM.jl\nSuiteSparseGraphBLAS","category":"page"},{"location":"","page":"Home","title":"Home","text":"In aggiunta, CVD-Lab fornisce il package ViewerGL, un viewer OpenGL 3D interattivo utilizzabile per gli esempi di questo modulo.","category":"page"},{"location":"#Installazione","page":"Home","title":"Installazione","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/Panemiele/LarCongruence.jl","category":"page"}]
}
