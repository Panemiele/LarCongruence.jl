var documenterSearchIndex = {"docs":
[{"location":"documentazioni/sparseMatrix/","page":"Sparse Matrix","title":"Sparse Matrix","text":"LarCongruence.cellCongruenceSM_OPT","category":"page"},{"location":"documentazioni/sparseMatrix/#LarCongruence.cellCongruenceSM_OPT","page":"Sparse Matrix","title":"LarCongruence.cellCongruenceSM_OPT","text":"cellCongruenceSM_OPT(cop, lo_cls, lo_sign)\n\nValuta la congruenza tra celle per una cocatena cop utilizzando le classi lo_cls, cioè la mappa che identifica per ciascun nuovo vertice calcolato identifica i vecchi vertici di partenza.\n\nLa funzione determina il nuovo operatore di cocatena costruito a partire da cop dove viene eseguito il merge delle celle di ordine inferiore secondo la mappa lo_cls. lo_sign specifica se una cella debba essere considerata nel verso opposto.\n\nSe il parametro opzionale imp vale true, allora le imprecizioni vengono tenute in considerazione nel senso che le celle di ordine inferiore potrebbero collidere. Il parametro d rappresenta, quindi l'ordine della cella (corrisponde anche al numero minimo di celle  di ordine inferiore di cui la cella corrente deve essere costituita).\n\nArgomenti\n\ncop::Lar.ChainOp\nlo_cls::Array{Array{Int,1},1}\nlo_sign::Array{Array{Int8,1},1}\nimp = false\nd = 0\n\nReturn\n\n(nrows, ho_cls, ho_sign)::Tuple{ Lar.ChainOp,  Array{Array{Int,1},1},  Array{Array{Int8,1},1} }\n\n\n\n\n\n","category":"function"},{"location":"documentazioni/sparseMatrix/","page":"Sparse Matrix","title":"Sparse Matrix","text":"LarCongruence.chainCongruenceSM_OPT","category":"page"},{"location":"documentazioni/sparseMatrix/#LarCongruence.chainCongruenceSM_OPT","page":"Sparse Matrix","title":"LarCongruence.chainCongruenceSM_OPT","text":"chainCongruenceSM_OPT(G, T)\n\nCalcola la congruenza della geometria G e coerentemente trasforma la topologia T\n\nArgomenti\n\nG::Lar.Points\nT::Array{Lar.ChainOp}\nimp=false\nϵ=1e-6\n\nReturn\n\n(G, Tn)::Tuple{Lar.Points, TnArray{Lar.ChainOp}}\n\n\n\n\n\n","category":"function"},{"location":"documentazioni/graphBLAS/","page":"GraphBLAS","title":"GraphBLAS","text":"LarCongruence.cellCongruence_OPT","category":"page"},{"location":"documentazioni/graphBLAS/#LarCongruence.cellCongruence_OPT","page":"GraphBLAS","title":"LarCongruence.cellCongruence_OPT","text":"cellCongruence_OPT(Delta, classes)\n\nValuta ed esegue la congruenza tra celle per una geometria (in graphBLAS) Delta utilizzando le classi `classes', cioè la mappa che identifica per ciascun nuovo vertice calcolato identifica i vecchi vertici di partenza.\n\nArgomenti\n\nDelta::GrB_Matrix{T}\nclasses::Array{Array{Int,1},1}\n\nReturn\n\n(res, eclasses)::Tuple{Matrix{Float64}, Vector{GrB_Matrix{Int8}}}\n\n\n\n\n\n","category":"function"},{"location":"documentazioni/graphBLAS/","page":"GraphBLAS","title":"GraphBLAS","text":"LarCongruence.chainCongruenceGB_OPT","category":"page"},{"location":"documentazioni/graphBLAS/#LarCongruence.chainCongruenceGB_OPT","page":"GraphBLAS","title":"LarCongruence.chainCongruenceGB_OPT","text":"chainCongruenceGB_OPT(W, Top)\n\nCalcola la congruenza della geometria W e coerentemente trasforma la topologia Top\n\nArgomenti\n\nW::Lar.Points\nTop::Vector{GrB_Matrix{Int8}}\n\nReturn\n\n(V, Topn)::Tuple{Lar.Points, TnArray{Lar.ChainOp}}\n\n\n\n\n\n","category":"function"},{"location":"grafoDipendenze/#Grafo-delle-dipendenze-originale","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze originale","text":"","category":"section"},{"location":"grafoDipendenze/","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze","text":"In questa sezione è rappresentato il grafo orientato delle dipendenze. Ogni arco orientato rappresenta una chiamata di funzione (v_1 v_2), dove v_1 è la funzione chiamante, e v_2 è la funzione chiamata. I nodi hanno un’etichetta corrispondente al nome del package mentre gli archi hanno un elenco di etichette corrispondenti alle coppie (v_1 v_2) precedentemente descritte.","category":"page"},{"location":"grafoDipendenze/","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze","text":"(Image: Grafo delle dipendenze)","category":"page"},{"location":"grafoDipendenze/#Come-realizzare-il-grafo","page":"Grafo delle dipendenze","title":"Come realizzare il grafo","text":"","category":"section"},{"location":"grafoDipendenze/","page":"Grafo delle dipendenze","title":"Grafo delle dipendenze","text":"Per quanto riguarda la costruzione del grafo, è stato utilizzato il package \" PkgDependency.jl \", il quale permette di ricavare tutte le dipendenze di un package e le va a mostrare sotto forma di albero. Successivamente, utilizzato le informazioni ottenute tramite il package, è stato creato il grafo sulla piattaforma online \" diagrams.net\", precedentemente nota come \"draw.io\".","category":"page"},{"location":"documentazioni/verticesCongruence/#Vertices-Congruence","page":"Vertices Congruence","title":"Vertices Congruence","text":"","category":"section"},{"location":"documentazioni/verticesCongruence/","page":"Vertices Congruence","title":"Vertices Congruence","text":"LarCongruence.vertCongruenceOptimized","category":"page"},{"location":"documentazioni/verticesCongruence/#LarCongruence.vertCongruenceOptimized","page":"Vertices Congruence","title":"LarCongruence.vertCongruenceOptimized","text":"vertCongruenceOptimized(V)\n\nValuta ed esegue la congruenza di vertici per punti 3D V  ℳ(3n).\n\nLa funzione determina i punti di V più vicini di ϵ e costruisce un nuovo insieme di vertici costituito dal rappresentativo per ciascun cluster di punti. Per fare ciò si utilizza l'algoritmo KDTree fornito dal package NearestNeighbors.\n\nIl metodo restituisce:\n\nil nuovo insieme di vertici\nuna mappa che, per ogni nuovo vertice, identifica i vecchi vertici nell'insieme di partenza\n\nArgomenti\n\n'V::Lar.Array{Float64,2}'\n'ϵ=1e-6'\n\nReturn\n\n(V, Vcls)::Tuple{Lar.Points, Array{Array{Int,1},1}}\n\n\n\n\n\n","category":"function"},{"location":"documentazioni/verticesCongruence/","page":"Vertices Congruence","title":"Vertices Congruence","text":"err = 1e-8\nV = [\n    0.0  err  0.0 -err  0.0  0.0\n    0.0  0.0  err  0.0 -err  0.0\n]\n\nLC.vertCongruenceOptimized(V[:, 1:5])\n\nLC.vertCongruenceOptimized(V[:, 2:6])","category":"page"},{"location":"documentazioni/verticesCongruence/#Variante-per-implementazione-AA","page":"Vertices Congruence","title":"Variante per implementazione AA","text":"","category":"section"},{"location":"documentazioni/verticesCongruence/","page":"Vertices Congruence","title":"Vertices Congruence","text":"LarCongruence.vertCongruenceAA_OPT","category":"page"},{"location":"documentazioni/verticesCongruence/#LarCongruence.vertCongruenceAA_OPT","page":"Vertices Congruence","title":"LarCongruence.vertCongruenceAA_OPT","text":"vertCongruenceAA_OPT(W)\n\nValuta ed esegue la congruenza di vertici per punti 3D W  ℳ(3n).\n\nLa funzione determina i punti di W più vicini di err (definito all'interno della funzione, valore pari a 10^-6) e costruisce un nuovo insieme di vertici costituito dal rappresentativo  per ciascun cluster di punti. Per fare ciò si utilizza l'algoritmo KDTree fornito dal package  NearestNeighbors.\n\nIl metodo restituisce:\n\nil nuovo insieme di vertici\nuna mappa che, per ogni nuovo vertice, identifica i vecchi vertici nell'insieme di partenza\n\nArgomenti\n\n'V::Lar.Array{Float64,2}'\n\nReturn\n\n(V, vclasses)::Tuple{Lar.Points, Array{Array{Int,1},1}}\n\n\n\n\n\n","category":"function"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"In questa sezione, verranno introdotti i principali concetti matematici e tecnologici utilizzati all'interno del progetto LarCongruence.jl.","category":"page"},{"location":"theory/#Matrici-Sparse","page":"Introduzione","title":"Matrici Sparse","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"In analisi numerica, una matrice sparsa è una matrice i cui valori sono quasi tutti uguali a zero. I pochi valori presenti sono distribuiti in modo casuale, cioè non si concentrano in determinate aree specifiche (Cluster).","category":"page"},{"location":"theory/#Semiring","page":"Introduzione","title":"Semiring","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Un Semiring è una struttura algebrica che generalizza l'aritmetica reale rimpiazzando (+,·) con l'operazione binaria (Op1, Op2). Un Semiring, in GraphBLAS, viene definito come l'unione di un monoide M e un operatore binario moltiplicativo F};","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Il monoide è una struttura algebrica formata da un operatore binario associativo e commutativo di tipo additivo} e da un dominio D che deve contenere anche un elemento vuoto (simbolo dell'operatore: ⊕);\nL'operatore binario F è formato invece da due domini di input e un dominio di output (simbolo dell'operatore: ⊗).","category":"page"},{"location":"theory/#GraphBLAS","page":"Introduzione","title":"GraphBLAS","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"GraphBLAS è la libreria che offre funzioni per matrici sparse, la più comune quando si parla di calcolo parallelo e distribuito. Questa libreria offre metodi smart ed efficaci per memorizzare valori ed effettuare operazioni su di essi all'interno di matrici sparse. Si può scegliere di implementare GraphBLAS sia sulla CPU che su GPU (la cosa interessante delle GPU è che lo si può fare in parallelo). Si usano le matrici per rappresentare i grafi, in modo da poter utilizzare le operazioni dell'algebra lineare che sono molto veloci da eseguire: il prodotto fra matrici, per esempio, permette di ricavare informazioni sui percorsi possibili e nodi vicini. GraphBLAS utilizza oggetti matematici chiamati \"Semirings\" che permettono di implementare qualsiasi operatore matematico e definire così un nuovo modello di prodotto matriciale. Due esempi:","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Plus-times: tipico prodotto matriciale\nTropical Semiring: usa i seguenti operatori:\ninterno: la somma\nesterno: il valore minimo","category":"page"},{"location":"theory/#Lar-Congruence","page":"Introduzione","title":"Lar Congruence","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"E' una libreria che ha l'obiettivo di eseguire la congruenza di celle e complessi di catene locali. Sono disponibili tre implementazioni di LarCongruence:","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Julia Native Sparse Matrix\nArray of Arrays\nGraphBLAS - estende il funzionamento di GraphBLAS, oltre che ai grafi, anche ai complessi cellulari.","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Per calcolare la congruenza di complessi di catena locali si procede come segue: ","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Per ogni faccia, si costruisce il suo complesso di catene locale, cioè la partizione del piano bidimensionale (identificato con z=0) indotta dal bordo di quella faccia e da tutte le altre che la dividono. \nSi rimette assieme per calcolare la congruenza: dall'insieme di complessi di catene locali ad ognuna delle facce dell'input, bisogna arrivare ad un unico complesso, \"incollando\" fra loro in modo coerente i vari complessi locali.","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Si noti che l'operazione che può essere parallelizzata è la prima, questo perché viene eseguita in modo indipendente per ciascuna delle facce.","category":"page"},{"location":"theory/#SIMD","page":"Introduzione","title":"SIMD","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Single Instruction, Multiple Data (SIMD) è un metodo per parallelizzare i calcoli all'interno della CPU, per cui una singola operazione viene eseguita su più elementi di dati contemporaneamente. Le moderne architetture della CPU contengono set di istruzioni che possono farlo, operando su molti variabili contemporaneamente. Questo non rende ogni ciclo più veloce. In particolare, si noti che l'utilizzo di SIMD implica che l'ordine delle operazioni all'interno e attraverso il ciclo potrebbe cambiare. Il compilatore deve essere certo che il riordino sia sicuro prima che tenti di parallelizzare un ciclo","category":"page"},{"location":"theory/#Tasks","page":"Introduzione","title":"Tasks","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Un Task è semplicemente un insieme di istruzioni che possono essere sospese e riprese in qualsiasi momento all'interno di quell'insieme. Una funzione può anche essere pensata come un insieme di istruzioni, e quindi di attività può essere visto come qualcosa di simile. Ma ci sono due differenze fondamentali:","category":"page"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"Non c'è overhead per passare da un Task all'altro, il che significa che non viene riservato spazio nello stack per un cambio;\na differenza di una funzione che deve terminare prima che il controllo torni al chiamante, un Task può essere interrotto e il controllo può essere passato a un altro Task in molti momenti diversi durante la sua esecuzione. In altre parole, nelle attività non esiste una relazione gerarchica chiamante-chiamato. Questo da l'impressione di lavorare in parallelo.","category":"page"},{"location":"theory/#Threads","page":"Introduzione","title":"Threads","text":"","category":"section"},{"location":"theory/","page":"Introduzione","title":"Introduzione","text":"I Thread sono sequenze di calcolo che possono essere eseguite indipendentemente su un core della CPU, contemporaneamente ad altre sequenze simili. A differenza dei task, che sono leggeri, i thread devono memorizzare uno stato quando vengono scambiati. Così, mentre si possono avere centinaia o migliaia di task in esecuzione, è opportuno avere solamente un numero limitato di Thread, tipicamente pari al numero di core della macchina in uso.","category":"page"},{"location":"authors/#A-Autori","page":"Autori","title":"A - Autori","text":"","category":"section"},{"location":"authors/","page":"Autori","title":"Autori","text":"Questo repository è stato creato, curato e mantenuto da Gabriele Romualdi e Simone Chilosi, studenti del corso magistrale in Ingegneria Informatica presso l'Università degli Studi di Roma Tre.","category":"page"},{"location":"authors/#[Gabriele-Romualdi](https://github.com/Panemiele)","page":"Autori","title":"Gabriele Romualdi","text":"","category":"section"},{"location":"authors/","page":"Autori","title":"Autori","text":"Linkedin","category":"page"},{"location":"authors/#[Simone-Chilosi](https://github.com/simochilo)","page":"Autori","title":"Simone Chilosi","text":"","category":"section"},{"location":"authors/","page":"Autori","title":"Autori","text":"Linkedin","category":"page"},{"location":"documentazioni/arrayOfArrays/","page":"Array of Arrays","title":"Array of Arrays","text":"LarCongruence.cellCongruenceAA_OPT","category":"page"},{"location":"documentazioni/arrayOfArrays/#LarCongruence.cellCongruenceAA_OPT","page":"Array of Arrays","title":"LarCongruence.cellCongruenceAA_OPT","text":"cellCongruenceAA_OPT(Delta, inclasses)\n\nValuta la congruenza tra celle per una parte di topologia Delta utilizzando le classi inclasses, cioè la mappa che identifica per ciascun nuovo vertice calcolato i vecchi vertici di partenza,  oppure la mappa che identifica per ciascun nuovo bordo calcolato i vecchi bordi di partenza.\n\nLa funzione restituisce: \t- la matrice che rappresenta i nuovi bordi calcolati e la mappa che li lega ai bordi di partenza  \t  se in input viene passato un insieme di vertici e la mappa che li lega ai vertici di partenza. \t- la matrice che rappresenta le nuove facce calcolate e la mappa che le lega alle facce di partenza \t  se in input viene passato un insieme di bordi e la mappa che li lega ai bordi di partenza.\n\nArgomenti\n\nDelta::SparseMatrixCSC{Int8, Int64}\ninclasses::Vector{Any}\n\nReturn\n\n(FEnew, outclasses)::Tuple{ Vector{Vector{Int64}},  Vector{Vector{Int64}}}\n\n\n\n\n\n","category":"function"},{"location":"documentazioni/arrayOfArrays/","page":"Array of Arrays","title":"Array of Arrays","text":"LarCongruence.chainCongruenceAA_OPT","category":"page"},{"location":"documentazioni/arrayOfArrays/#LarCongruence.chainCongruenceAA_OPT","page":"Array of Arrays","title":"LarCongruence.chainCongruenceAA_OPT","text":"chainCongruenceAA_OPT(W, T)\n\nCalcola la congruenza della geometria W e coerentemente trasforma la topologia T La funzione restituisce tra matrici di incidenza/adiacenza: \t- V (il nuovo insieme di vertici calcolato con vertCongruenceAAOPT) \t- EV (matrice di adiacenza bordi/vertici, calcolata con cellCongruenceOPT utilizzando vclasses) \t- FE (matrice di adiacenza facce/bordi, calcolata con cellCongruence_OPT utilizzando eclasses)\n\nArgomenti\n\nW::Lar.Points\nT::Vector{SparseMatrixCSC{Int8, Int64}}\n\nReturn\n\n(V, EV, FE)::Tuple{Lar.Points, Vector{Vector{Int64}}, Vector{Vector{Int64}}}\n\n\n\n\n\n","category":"function"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"In questa sezione, verranno discussi gli step seguiti durante l'avanzamento del progetto.","category":"page"},{"location":"sviluppo/#Studio-preliminare","page":"Sviluppo","title":"Studio preliminare","text":"","category":"section"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"In questa prima fase, gli sforzi sono stati concentrati sullo studio della teoria di base legata intrinsecamente al progetto:","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Accezioni e nomenclature matematiche (es: monoidi, semirings, matrici sparse, ...)\nStudio delle strutture algebriche (es: celle, catene, cocatene, ...)\nStudio del linguaggio Julia (sintassi, funzioni, macro, ...)\nConcetti base sul funzionamento di GraphBLAS e funzioni Julia (SuiteSparseGraphBLAS e GraphBLASInterface)\nConcetti base sul funzionamento di Local Congruence (Sparse Matrix, Array of Arrays e GraphBLAS stesso)","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Inoltre, ci si è concentrati sulla realizzazione di un buon grafo delle dipendenze.","category":"page"},{"location":"sviluppo/#Studio-esecutivo","page":"Sviluppo","title":"Studio esecutivo","text":"","category":"section"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Il secondo step racchiude il modo in cui sono stati modificate le funzioni dei progetti cea-SM.jl, cea-GB.jl e cea-AA.jl, in modo tale da introdurre un buon grado di parallelismo e migliorare le prestazioni. Per fare ciò, sono state utilizzate le funzioni e le macro offerte da Julia che permettono di operare in modo parallelo tramite semplice annotazioni; i concetti chiave utilizzati sono:","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Threads\nTasks\nSimd","category":"page"},{"location":"sviluppo/#Modifiche-effettuate","page":"Sviluppo","title":"Modifiche effettuate","text":"","category":"section"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Ci si è concentrati sul migliorare la funzione \"CellCongruence()\" in tutte e tre le implementazioni (SS, AA, e GB): questa funzione ha l’obiettivo di eseguire la congruenza di celle e complessi di celle tra la geometria e la topologia passate in input. Poiché questo processo può essere eseguito in modo indipendente faccia per faccia, risulta opportuno parallelizzare la funzione tramite le macro fornite da Julia. A tale scopo, sono state attuate le seguenti modifiche:","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Sparse Matrix: \nla funzione vertCongruence (dal file verticesCongruence.jl) `e stata modifica in vertCongruen-","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"ceOptimized (nel file verticesCongruence-optimized.jl), aggiungendo l’utilizzo dei Tasks;     * la funzione chainCongruenceSM OPT(...) è stata migliorata sfruttando i Tasks;     * la funzione cellCongruenceSM OPT(...) è stata migliorata sfruttando i Tasks e SIMD.","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"GraphBLAS: Per quanto riguarda GraphBLAS, è stato scelto di implementare una sola modifica, per non penalizzare","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"le performance: sono stati usati i Thread (in particolare 6) per eseguire la funzione cellCongruen- ce OPT(...)","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Array of Arrays:\n","category":"page"},{"location":"sviluppo/#Studio-definitivo","page":"Sviluppo","title":"Studio definitivo","text":"","category":"section"},{"location":"sviluppo/#Riferimenti","page":"Sviluppo","title":"Riferimenti","text":"","category":"section"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Per consultare il codice, si rimanda al link del repository GitHub, mentre per uno studio approfondito delle varie macro di Julia sopracitate, verranno elencati i vari link della documentazione:","category":"page"},{"location":"sviluppo/","page":"Sviluppo","title":"Sviluppo","text":"Threads\nTasks\nSIMD","category":"page"},{"location":"graph_blas/#Introduction-to-GraphBLAS-Framework","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"","category":"section"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"GraphBLAS is an API that defines a set of sparse matrix operation based on an algebra of semirings and designed to do computation on graphs.","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"Local congruence of Chain Complexes extends GraphBLAS domain from graphs to cellular complexes.","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"An interface to SuiteSparse:GraphBLAS C library for Julia is provided by two library: SuiteSparseGraphBLAS.jl and GraphBLASInterface.jl.","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"Each GraphBLAS function operates on a semiring S = langle D_out D_in1 D_in2 bigoplus bigotimes 0 rangle, defined by three domains D_out D_in1 D_in2, two binary operators, a commutative and an associative additive operation bigoplus  D_out times D_out rightarrow D_out and a multiplicative operation bigotimes  D_in1 times D_in2 rightarrow D_out, and an identity element 0 in D_out, that satisfies the following two conditions in their respective domains:","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"Additive identity: a bigoplus 0 = a\nMultiplicative annihilation: a bigotimes 0 = 0","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"A single domain D, together with an associative operation bigodot  D times D rightarrow D and an identity element 0 in D define a GraphBLAS monoid.","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"It is possible to create a monoid with a binary operator and an identity value, and a semiring with a monoid and a binary operator, respectively with GrB_Monoid_new(monoid, binary_op, identity) and GrB_Semiring_new(semiring, monoid, binary_op).","category":"page"},{"location":"graph_blas/","page":"3 - Introduction to GraphBLAS Framework","title":"3 - Introduction to GraphBLAS Framework","text":"With monoid and semirings, in GraphBLAS you can override the normal plus and times operators in matrices multiplications, performed with GrB_mxm, in order to define complex algorithm in the language of linear algebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Progetto LAR Congruence per il corso di Calcolo Parallelo e Distribuito svolto da:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Nome Matricola E-mail Profilo Github\nGabriele Romualdi 521111 gab.romualdi@stud.uniroma3.it https://github.com/Panemiele\nSimone Chilosi 522155 sim.chilosi@stud.uniroma3.it https://github.com/simochilo","category":"page"},{"location":"","page":"Home","title":"Home","text":"Link al repository GitHub: https://github.com/Panemiele/LarCongruence.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Link ai notebook:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Array Of Arrays: https://github.com/Panemiele/LarCongruence.jl/examples/notebooks/[CPD22-7a]notebook_ArrayOfArrays.ipynb\nGraphBLAS: https://github.com/Panemiele/LarCongruence.jl/examples/notebooks/[CPD22-7a]notebook_GraphBLAS.ipynb\nJulia Native Sparse Matrix: https://github.com/Panemiele/LarCongruence.jl/examples/notebooks/[CPD22-7a]notebook_JuliaNativeSparseMatrix.ipynb","category":"page"},{"location":"#LarCongruence.jl","page":"Home","title":"LarCongruence.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LarCongruence.jl è una libreria Julia che fornisce strumenti per gestire congruenze locali di complessi di catene.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In particolare, dato un insieme di complessi di catene locali secondo gli standard LinearAlgebraicRepresentation, questo modulo Julia calcola il singolo complesso globale corrispondente usando la epsilon-congruenza delle celle, risolvendo topologicamente le inesattezze numeriche dell'aritmetica dei floating-point.","category":"page"},{"location":"#Dipendenze","page":"Home","title":"Dipendenze","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LarCongruence.jl utilizza alcune dipendenze, di seguito elencate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"DataStructures.jl\nGraphBLASInterface.jl\nLinearAlgebraicRepresentation\nNearestNeighbors.jl\nSparseArrays.jl\nSparseMM.jl\nSuiteSparseGraphBLAS","category":"page"},{"location":"","page":"Home","title":"Home","text":"In aggiunta, CVD-Lab fornisce in aggiunta il package ViewerGL, un viewer OpenGL 3D interattivo utilizzabile per gli esempi di questo modulo.","category":"page"},{"location":"#Installazione","page":"Home","title":"Installazione","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/Panemiele/LarCongruence.jl","category":"page"}]
}
