<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Esempi e risultati · LarCongruence.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/LAR_Congruence.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="LarCongruence.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LarCongruence.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../theory/">Introduzione</a></li><li><a class="tocitem" href="../grafoDipendenze/">Grafo delle dipendenze</a></li><li><a class="tocitem" href="../sviluppo/">Sviluppo</a></li><li><span class="tocitem">Codice Sorgente e funzioni</span><ul><li><a class="tocitem" href="../documentazioni/verticesCongruence/">Vertices Congruence</a></li><li><a class="tocitem" href="../documentazioni/sparseMatrix/">Sparse Matrix</a></li><li><a class="tocitem" href="../documentazioni/graphBLAS/">GraphBLAS</a></li><li><a class="tocitem" href="../documentazioni/arrayOfArrays/">Array of Arrays</a></li></ul></li><li class="is-active"><a class="tocitem" href>Esempi e risultati</a><ul class="internal"><li><a class="tocitem" href="#Global-Set-up"><span>Global Set up</span></a></li><li><a class="tocitem" href="#Chain-Congruence-Versioni-normale-e-modificata"><span>Chain Congruence - Versioni normale e modificata</span></a></li><li><a class="tocitem" href="#Example-1-two-intersecting-cuboids-grid"><span>Example 1 - two intersecting cuboids grid</span></a></li><li><a class="tocitem" href="#Example-2-two-adjacent-cubes-on-faces"><span>Example 2 - two adjacent cubes on faces</span></a></li><li class="toplevel"><a class="tocitem" href="#Example-3-two-adjacent-cubes-on-the-edges"><span>Example 3 - two adjacent cubes on the edges</span></a></li><li class="toplevel"><a class="tocitem" href="#Example-4-two-near-cubes"><span>Example 4 - two near cubes</span></a></li><li class="toplevel"><a class="tocitem" href="#Example-5-Grid-inside-another-grid"><span>Example 5 - Grid inside another grid</span></a></li><li class="toplevel"><a class="tocitem" href="#Example-6-Grid-inside-another-grid-(BIG)"><span>Example 6 - Grid inside another grid (BIG)</span></a></li><li class="toplevel"><a class="tocitem" href="#Example-7-100x50-cuboids-table"><span>Example 7 - 100x50 cuboids table</span></a></li><li class="toplevel"><a class="tocitem" href="#Confronto-versioni-&quot;chainCongruence()-tra-le-varie-implementazioni&quot;"><span>Confronto versioni &quot;chainCongruence() tra le varie implementazioni&quot;</span></a></li><li class="toplevel"><a class="tocitem" href="#Julia-Native-Sparse-Matrix"><span>Julia Native Sparse Matrix</span></a></li><li class="toplevel"><a class="tocitem" href="#GraphBLAS"><span>GraphBLAS</span></a></li><li class="toplevel"><a class="tocitem" href="#Array-of-Arrays"><span>Array of Arrays</span></a></li></ul></li><li><a class="tocitem" href="../authors/">Autori</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Esempi e risultati</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Esempi e risultati</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Panemiele/LarCongruence.jl/blob/main/docs/src/esempi.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Esempi"><a class="docs-heading-anchor" href="#Esempi">Esempi</a><a id="Esempi-1"></a><a class="docs-heading-anchor-permalink" href="#Esempi" title="Permalink"></a></h1><p>In questa sezione, verranno mostrati diversi esempi per mostrare la correttezza degli input e degli output:</p><ul><li>Alcuni di questi esempi sono di dimensioni contenute, per introdurre il lettore in modo graduale;</li><li>Altri esempi invece hanno dimensioni sufficientemente grandi da &quot;mettere in crisi&quot; un calcolatore con specifiche medie;</li><li>Altri ancora sono più complessi e, oltre a mostrare la correttezza dell&#39;output, mostrano l&#39;effetto della funzione &quot;chainCongruence()&quot;, la quale riduce le dimensioni delle matrici EV ed FV (la dimensione si riduce perché vengono rimossi vertici, facce e spigoli duplicati);</li></ul><p>In questi esempi, sono mostrate anche le differenze tra una versione non ottimizzata di &quot;chainCongruence()&quot; ed una ottimizzata. E&#39; stato usato in modo massiccio ViewerGL, così da poter verificare in modo visuale la correttezza dell&#39;output generato.</p><div class="admonition is-info"><header class="admonition-header">Nota</header><div class="admonition-body"><p>La funzione <strong>chainCongruence()</strong> utilizzata in questi esempi fa riferimento all&#39;implementazione di ***Array of Arrays***; verranno mostrati i confronti tra le varie implementazioni nella prossima sezione.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Limiti di Space Arrangement</header><div class="admonition-body"><p>La funzione <strong>space_arrangement()</strong> usata negli esempi potrebbe impiegare davvero tanto tempo per input molto grandi e, probabilmente, entrerà in loop. Si consiglia, pertanto, di effettuare dei test sulla macchina utilizzata al fine di studiarne i range possibili.<img src="../assets/SpaceArrangementTooLong.png" alt="Edges-Vertices"/></p></div></div><h2 id="Global-Set-up"><a class="docs-heading-anchor" href="#Global-Set-up">Global Set up</a><a id="Global-Set-up-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Set-up" title="Permalink"></a></h2><p>Prima di lanciare gli esempi, verrà preparato l&#39;ambiente adatto: si importano le librerie necessarie al corretto funzionamento, quali: LinearAlgebraicRepresentation, LarCongruence, ViewerGL. Successivamente, vengono definite delle versioni migliorate delle funzioni <strong>chainCongruence()</strong> e <strong>coboundary_1()</strong>: le modifiche apportate fanno si che entrambe le funzioni si comportino in modo adeguato su input di grandi dimenzioni.&lt;br&gt;&lt;br&gt;Dopo il set up, si è pronti a lanciare gli esempi in tutta libertà.</p><pre><code class="language-julia hljs">using BenchmarkTools
using ViewerGL, LinearAlgebra
using LinearAlgebraicRepresentation
using NearestNeighbors, DataStructures, SparseArrays
using StatsAPI
using SparseMM
using LarCongruence
using Images
using Colors
using Plots
using Base.Threads
using SparseArrays
using DataStructures
using NearestNeighbors
using LinearAlgebra
nthreads()</code></pre><pre><code class="language-julia hljs">Lar= LinearAlgebraicRepresentation;
L = Lar;
LC = LarCongruence;
using ViewerGL;
GL = ViewerGL;</code></pre><h2 id="Chain-Congruence-Versioni-normale-e-modificata"><a class="docs-heading-anchor" href="#Chain-Congruence-Versioni-normale-e-modificata">Chain Congruence - Versioni normale e modificata</a><a id="Chain-Congruence-Versioni-normale-e-modificata-1"></a><a class="docs-heading-anchor-permalink" href="#Chain-Congruence-Versioni-normale-e-modificata" title="Permalink"></a></h2><p>Prima di proseguire con gli esempi, verranno definite le funzioni utilizzate per calcolare la congruenza; in particolare, vengono proposte due versioni:</p><ul><li><strong>chainCongruenceAA()</strong>, versione normale della funzione, basata su Array of Arrays;</li><li><strong>chainCongruenceAA_OPT()</strong>, versione che sfrutta i tasks.&lt;br&gt;</li></ul><p>La funzione chainCongruenceAA() è stata modificata aggiungendo a <strong>cellCongruenceAA_OPT()</strong> l&#39;utilizzo dei tasks, precisamente nel primo for: quì vengono scorse le classi di vertices (se viene chiamata cellCongruenceAA_OPT(T[1],vclasses) ) o di edges (se invece viene chiamata cellCongruenceAA(T[2],eclasses); la cardinalità di vclasses, per esempio, è pari al numero di vertici della geometria, perciò più grande questa è grande, maggiore è la necessità di rendere asincrona questa porzione di codice. </p><h2 id="Example-1-two-intersecting-cuboids-grid"><a class="docs-heading-anchor" href="#Example-1-two-intersecting-cuboids-grid">Example 1 - two intersecting cuboids grid</a><a id="Example-1-two-intersecting-cuboids-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1-two-intersecting-cuboids-grid" title="Permalink"></a></h2><h3 id="Grid-size:-3x3x3brCells-number:-27x2-54"><a class="docs-heading-anchor" href="#Grid-size:-3x3x3brCells-number:-27x2-54">Grid size: 3x3x3&lt;br&gt;Cells number: 27x2 = 54</a><a id="Grid-size:-3x3x3brCells-number:-27x2-54-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-size:-3x3x3brCells-number:-27x2-54" title="Permalink"></a></h3><p>Questo piccolo esempio è stato proposto per mostrare, innanzitutto, la corretta creazione delle griglie di input e la corretta visualizzazione dell&#39;output. L&#39;approccio seguito in questo esempio (la struttura dell&#39;esempio stesso e l&#39;utilizzo di ViewerGL) verrà riproposto anche nei successivi.&lt;br&gt; Le due griglie, che differiscono leggermente di posizione e rotazione, sono intersecate fra loro e possiedono, in totale, un numero pari a 54 celle (27 per griglia). Data la traslazione e la rotazione di cui sopra, non è ancora possibile, in questo esempio, mostrare il comportamento della funzione <strong>chainCongruence()</strong>; tuttavia, rimane un buon esempio iniziale per comprendere il dominio applicativo. <img src="assets/3x3x3%20CuboidGrid/TwoSimpleCuboidsGridEV.png" alt="Edges-Vertices"/> <img src="assets/3x3x3%20CuboidGrid/TwoSimpleCuboidsGridFV.png" alt="Facets-Vertices"/> Per completare l&#39;esempio e mostrare il pattern seguito nei vari esempi, vengono mostrati ulteriori dettagli grafici; questi permettono, in ordine, di mostrare:</p><ul><li>vertici e facce della geometria numerati:</li></ul><p><img src="assets/3x3x3%20CuboidGrid/TwoSimpleCuboidsGridNumbering.png" alt="Numbering"/></p><ul><li>le facce della geometria:</li></ul><p><img src="assets/3x3x3%20CuboidGrid/TwoSimpleCuboidsGridFacets.png" alt="Explode Facets"/></p><ul><li>gli spigoli della geometria:</li></ul><p><img src="assets/3x3x3%20CuboidGrid/TwoSimpleCuboidsGridEdges.png" alt="Explode Edges"/></p><ul><li>la decomposizione della geometria:</li></ul><p><img src="assets/3x3x3%20CuboidGrid/TwoSimpleCuboidsGridComp.png" alt="Decomposition"/></p><h2 id="Example-2-two-adjacent-cubes-on-faces"><a class="docs-heading-anchor" href="#Example-2-two-adjacent-cubes-on-faces">Example 2 - two adjacent cubes on faces</a><a id="Example-2-two-adjacent-cubes-on-faces-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2-two-adjacent-cubes-on-faces" title="Permalink"></a></h2><h3 id="Cubes-number:-2"><a class="docs-heading-anchor" href="#Cubes-number:-2">Cubes number: 2</a><a id="Cubes-number:-2-1"></a><a class="docs-heading-anchor-permalink" href="#Cubes-number:-2" title="Permalink"></a></h3><p>Quest&#39;altro piccolo esempio permette di osservare il comportamento della funzione <strong>chainCongruence()</strong> in modo molto semplice.</p><ul><li>vengono creati due cubi adiacenti su una delle loro facce (verrà aggiunta una distanza di 0.0000001 tra un cubo ed un altro per evitare che la funzione <strong>cuboid()</strong> risolva la congruenza al posto della funzione <strong>chainCongruence()</strong>);</li><li>tali cubi sono creati in modo separato, perciò <strong>essi avranno i vertici e la faccia</strong> su cui risultano adiacenti <strong>duplicati</strong>;</li><li>godendo di queste caratteristiche, alla geometria può essere applicata la funzione <strong>chainCongruence()</strong> che fa si che i vertici e le facce duplicate vengano rimosse, mettendo &quot;a fattor comune&quot; vertici e facce su cui i cubi risultano adiacenti</li></ul><p>Essendo due cubi, ci si aspetta di passare, per quanto riguarda il <strong>numero di vertici distinti</strong>, <strong>da 16 a 12</strong> mentre per le <strong>facce distinte</strong> ci si aspetta di passare <strong>da 12</strong> (6 per cubo) <strong>a 8</strong>: questo perché 4 vertici + 1 faccia sono in comune tra i due cubi e, perciò, la funzione utilizzata rimuoverà tali copie. <img src="../assets/adjacentOnFace/EV.png" alt="Edges-Vertices"/> <img src="../assets/adjacentOnFace/FV.png" alt="Facets-Vertices"/></p><h3 id="Chain-Congruence-application"><a class="docs-heading-anchor" href="#Chain-Congruence-application">Chain Congruence application</a><a id="Chain-Congruence-application-1"></a><a class="docs-heading-anchor-permalink" href="#Chain-Congruence-application" title="Permalink"></a></h3><p><strong>Verrà ora dimostrato che la dimensione di EV ottenuto dopo la congruenza è minore rispetto a quello iniziale.</strong> Questo è dovuto al fatto che 4 vertici ed una faccia risultano duplicati e la funziona &quot;chainCongruence()&quot; li ha eliminati (come volevasi dimostrare: <strong>EV - EV_B = 24 - 20 = 4</strong> vertici doppioni eliminati). La figura risultante, come si vede dall&#39;immagine sottostante, è esattamente identica a quella iniziale, nonostante l&#39;eliminazione dei vertici duplicati. <img src="../assets/adjacentOnFace/AfterCongruence.png" alt="After congruence"/> Anche in questo caso, vengono mostrati ulteriori dettagli grafici: <img src="../assets/adjacentOnFace/Numbering.png" alt="Numbering"/> <img src="../assets/adjacentOnFace/Facets.png" alt="Explode Facets"/> <img src="../assets/adjacentOnFace/Edges.png" alt="Explode Edges"/> <img src="../assets/adjacentOnFace/Comp.png" alt="Decomposition"/></p><h1 id="Example-3-two-adjacent-cubes-on-the-edges"><a class="docs-heading-anchor" href="#Example-3-two-adjacent-cubes-on-the-edges">Example 3 - two adjacent cubes on the edges</a><a id="Example-3-two-adjacent-cubes-on-the-edges-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3-two-adjacent-cubes-on-the-edges" title="Permalink"></a></h1><h3 id="Cubes-number:-2-2"><a class="docs-heading-anchor" href="#Cubes-number:-2-2">Cubes number: 2</a><a class="docs-heading-anchor-permalink" href="#Cubes-number:-2-2" title="Permalink"></a></h3><p>Un altro esempio di dimensioni contenute; anche quì si osserva il comportamento della funzione <strong>chainCongruence()</strong>.</p><ul><li>vengono creati due cubi adiacenti su uno dei loro spigoli (verrà aggiunta una distanza di 0.0000001 tra un cubo ed un altro per evitare che la funzione <strong>cuboid()</strong> risolva la congruenza al posto della funzione <strong>chainCongruence()</strong>);</li><li>tali cubi sono creati in modo separato, perciò <strong>essi avranno lo spigolo</strong> su cui risultano adiacenti <strong>duplicato</strong>;</li><li>godendo di queste caratteristiche, alla geometria può essere applicata la funzione <strong>chainCongruence()</strong> che fa si che lo spigolo duplicato venga rimosso, mettendolo &quot;a fattor comune&quot;.</li></ul><p>Essendo due cubi, ci si aspetta di passare, per quanto riguarda il <strong>numero di spigoli</strong>, <strong>da 24 a 23</strong>: questo perché lo spigolo è in comune tra i due cubi e, perciò, la funzione utilizzata rimuoverà una delle due copie. <img src="../assets/adjacentOnEdge/EV.png" alt="Edges-Vertices"/> <img src="../assets/adjacentOnEdge/FV.png" alt="Facets-Vertices"/></p><h3 id="Chain-Congruence-application-2"><a class="docs-heading-anchor" href="#Chain-Congruence-application-2">Chain Congruence application</a><a class="docs-heading-anchor-permalink" href="#Chain-Congruence-application-2" title="Permalink"></a></h3><p><strong>Verrà ora dimostrato che la dimensione di EV ottenuto dopo la congruenza è minore rispetto a quello iniziale.</strong> Questo è dovuto al fatto che uno spigolo risulta duplicato e la funzione &quot;chainCongruence()&quot; lo ha eliminato (come volevasi dimostrare: <strong>EV - EV_B = 24 - 23 = 1</strong> spigolo doppione eliminato). La figura risultante, come si vede dall&#39;immagine sottostante, è esattamente identica a quella iniziale, nonostante l&#39;eliminazione dello spigolo duplicato. <img src="../assets/adjacentOnEdge/AfterCongruence.png" alt="After congruence"/> Come per gli altri esempi, vengono mostrati ulteriori dettagli grafici: <img src="../assets/adjacentOnEdge/Numbering.png" alt="Numbering"/> <img src="../assets/adjacentOnEdge/Facets.png" alt="Explode Facets"/> <img src="../assets/adjacentOnEdge/Edges.png" alt="Explode Edges"/> <img src="../assets/adjacentOnEdge/Comp.png" alt="Decomposition"/></p><h1 id="Example-4-two-near-cubes"><a class="docs-heading-anchor" href="#Example-4-two-near-cubes">Example 4 - two near cubes</a><a id="Example-4-two-near-cubes-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4-two-near-cubes" title="Permalink"></a></h1><h3 id="Cubes-number:-2-3"><a class="docs-heading-anchor" href="#Cubes-number:-2-3">Cubes number: 2</a><a class="docs-heading-anchor-permalink" href="#Cubes-number:-2-3" title="Permalink"></a></h3><p>Quest&#39;ultimo esempio di piccole dimensioni viene proposto per capire i limiti di applicazione della funzione <strong>chainCongruence()</strong>.</p><ul><li>vengono creati due cubi:<ul><li>Lo spigolo di uno dei due giace su una delle facce dell&#39;altro</li></ul></li><li>tali cubi sono creati in modo separato, perciò essi saranno composti da vertici, facce e spigoli <strong>distinti</strong>;</li><li>godendo di queste caratteristiche, alla geometria può essere applicata la funzione <strong>chainCongruence()</strong>, <strong>MA essa non avrà alcun effetto</strong>: infatti, dato che non ci sono vertici, facce o spigoli in comune tra i due cubi, non esistono duplicati di essi, quindi la funzione non rimuoverà nulla.</li></ul><p><img src="../assets/nearCube/EV.png" alt="Edges-Vertices"/> <img src="../assets/nearCube/FV.png" alt="Facets-Vertices"/></p><h3 id="Chain-Congruence-application-3"><a class="docs-heading-anchor" href="#Chain-Congruence-application-3">Chain Congruence application</a><a class="docs-heading-anchor-permalink" href="#Chain-Congruence-application-3" title="Permalink"></a></h3><p><strong>Verrà ora dimostrato che la dimensione di EV ottenuto dopo la congruenza è uguale a quella iniziale.</strong> Questo è dovuto al fatto che non ci sono vertici, facce o spigoli duplicati e quindi la funzione &quot;chainCongruence()&quot; non ha modificato nulla. Nonostante ciò, la figura risultante è la stessa. <img src="../assets/nearCube/AfterCongruence.png" alt="After congruence"/> Come per gli altri esempi, vengono mostrati ulteriori dettagli grafici: <img src="../assets/nearCube/Numbering.png" alt="Numbering"/> <img src="../assets/nearCube/Facets.png" alt="Explode Facets"/> <img src="../assets/nearCube/Edges.png" alt="Explode Edges"/> <img src="../assets/nearCube/Comp.png" alt="Decomposition"/></p><h1 id="Example-5-Grid-inside-another-grid"><a class="docs-heading-anchor" href="#Example-5-Grid-inside-another-grid">Example 5 - Grid inside another grid</a><a id="Example-5-Grid-inside-another-grid-1"></a><a class="docs-heading-anchor-permalink" href="#Example-5-Grid-inside-another-grid" title="Permalink"></a></h1><h3 id="Small-Grid:-3x3x3brBig-grid:-5x5x5brCells-number:-27-125-134"><a class="docs-heading-anchor" href="#Small-Grid:-3x3x3brBig-grid:-5x5x5brCells-number:-27-125-134">Small Grid: 3x3x3&lt;br&gt;Big grid: 5x5x5&lt;br&gt;Cells number: 27 + 125 = 134</a><a id="Small-Grid:-3x3x3brBig-grid:-5x5x5brCells-number:-27-125-134-1"></a><a class="docs-heading-anchor-permalink" href="#Small-Grid:-3x3x3brBig-grid:-5x5x5brCells-number:-27-125-134" title="Permalink"></a></h3><p>Riprendendo l&#39;esempio precedente sulle griglie (il <strong>numero 1</strong>), ne verranno ora mostrate due di diverse dimensioni, con la più grande sovrapposta alla prima (le due griglie sono perfettamente congruenti sulle celle della più piccola tra le due). L&#39;obiettivo di questo esempio è mostrare come, applicando ***chainCongruence()***, sia possibile ridurre notevolmente il numero di vertici, facce e spigoli inizialmente creati, eliminando i doppioni; questa azione è necessaria perché le celle della griglia più piccola sono duplicate (la griglia più grande contiene celle nelle stesse identiche posizioni della più piccola, quindi vertici, spigoli e facce sono duplicate) <img src="../assets/littleTwoGrids/EV.png" alt="Edges-Vertices"/> <img src="../assets/littleTwoGrids/FV.png" alt="Facets-Vertices"/></p><h3 id="Chain-Congruence-application-4"><a class="docs-heading-anchor" href="#Chain-Congruence-application-4">Chain Congruence application</a><a class="docs-heading-anchor-permalink" href="#Chain-Congruence-application-4" title="Permalink"></a></h3><p><strong>Verrà ora dimostrato che la dimensione di EV ottenuto dopo la congruenza è minore rispetto a quello iniziale.</strong> Questo è dovuto al fatto che molti vertici risultano duplicati e la funziona &quot;chainCongruence()&quot; li ha eliminati (in particolare: <strong>EV<em>A - EV</em>B = 684 - 540 = 144</strong> vertici doppioni eliminati). La figura risultante, come si vede dall&#39;immagine sottostante, è esattamente identica a quella iniziale, nonostante l&#39;eliminazione dei vertici duplicati. <img src="../assets/littleTwoGrids/AfterCongruence.png" alt="After congruence"/> Come per gli altri esempi, vengono mostrati ulteriori dettagli grafici: <img src="../assets/littleTwoGrids/Numbering.png" alt="Numbering"/> <img src="../assets/littleTwoGrids/Facets.png" alt="Explode Facets"/> <img src="../assets/littleTwoGrids/Edges.png" alt="Explode Edges"/> <img src="../assets/littleTwoGrids/Comp.png" alt="Decomposition"/></p><h1 id="Example-6-Grid-inside-another-grid-(BIG)"><a class="docs-heading-anchor" href="#Example-6-Grid-inside-another-grid-(BIG)">Example 6 - Grid inside another grid (BIG)</a><a id="Example-6-Grid-inside-another-grid-(BIG)-1"></a><a class="docs-heading-anchor-permalink" href="#Example-6-Grid-inside-another-grid-(BIG)" title="Permalink"></a></h1><h3 id="Small-Grid:-10x10x10brBig-grid:-15x15x15brCells-number:-1000-3375-4375"><a class="docs-heading-anchor" href="#Small-Grid:-10x10x10brBig-grid:-15x15x15brCells-number:-1000-3375-4375">Small Grid: 10x10x10&lt;br&gt;Big grid: 15x15x15&lt;br&gt;Cells number: 1000 + 3375  = 4375</a><a id="Small-Grid:-10x10x10brBig-grid:-15x15x15brCells-number:-1000-3375-4375-1"></a><a class="docs-heading-anchor-permalink" href="#Small-Grid:-10x10x10brBig-grid:-15x15x15brCells-number:-1000-3375-4375" title="Permalink"></a></h3><p>Viene replicato l&#39;esempio precedente, ma con dimensioni delle griglie decisamente più grandi (4375 celle contro le 134 dell&#39;esempio precedente). L&#39;obiettivo è quello di spingere il calcolatore ad effettuare calcoli di grande portata, mettendolo in difficoltà. Anche quì, verrà dimostrata la correttezza dell&#39;output, sia della funzione <strong>chainCongruence()</strong>, sia delle funzioni per la presentazione grafica di ViewerGL. <img src="../assets/bigTwoGrids/EV.png" alt="Edges-Vertices"/> <img src="../assets/bigTwoGrids/FV.png" alt="Facets-Vertices"/></p><h3 id="Chain-Congruence-application-5"><a class="docs-heading-anchor" href="#Chain-Congruence-application-5">Chain Congruence application</a><a class="docs-heading-anchor-permalink" href="#Chain-Congruence-application-5" title="Permalink"></a></h3><p><strong>Verrà ora dimostrato che la dimensione di EV ottenuto dopo la congruenza è minore rispetto a quello iniziale.</strong> Questo è dovuto al fatto che molti spigoli risultano duplicati e la funziona &quot;chainCongruence()&quot; li ha eliminati (in particolare: <strong>EV<em>A - EV</em>B = 15150 - 11520 = 3630</strong> vertici doppioni eliminati). Come si può vedere, la griglia ottenuta è identica a quella di partenza, ma i vertici utilizzati per la sua creazione sono in numero minore. <img src="../assets/bigTwoGrids/AfterCongruence.png" alt="After congruence"/> Come per gli altri esempi, vengono mostrati ulteriori dettagli grafici: <img src="../assets/bigTwoGrids/Numbering.png" alt="Numbering"/> <img src="../assets/bigTwoGrids/Facets.png" alt="Explode Facets"/> <img src="../assets/bigTwoGrids/Edges.png" alt="Explode Edges"/> <img src="../assets/bigTwoGrids/Comp.png" alt="Decomposition"/></p><h1 id="Example-7-100x50-cuboids-table"><a class="docs-heading-anchor" href="#Example-7-100x50-cuboids-table">Example 7 - 100x50 cuboids table</a><a id="Example-7-100x50-cuboids-table-1"></a><a class="docs-heading-anchor-permalink" href="#Example-7-100x50-cuboids-table" title="Permalink"></a></h1><h3 id="Cells-number:-100x50-5000"><a class="docs-heading-anchor" href="#Cells-number:-100x50-5000">Cells number: 100x50 = 5000</a><a id="Cells-number:-100x50-5000-1"></a><a class="docs-heading-anchor-permalink" href="#Cells-number:-100x50-5000" title="Permalink"></a></h3><p>Questo esempio è stato pensato per testare le performance della funzione <strong>chainCongruence()</strong> nella sua versione normale e quella che sfrutta i tasks: ci si aspetterebbe un miglioramento nella seconda versione poiché questa presenta una piccola porzione di codice che lavora in modo asincrono; tale porzione, però, viene richiamata un numero di volte elevato, pari al numero di vertici nella geometria, ed essendo questa geometria molto vasta (il numero di vertici è alto), i benefici previsti dovrebbero essere alti (o quantomeno presenti). Il miglioramento sulla seconda versione, però, non si verifica: questo è dovuto alla semplicità della porzione di codice chiamata; seppur essa sia chiamata un numero di volte elevato, essendo molto semplice, <strong>risulta più complesso utilizzare la programmazione asincrona</strong> (e quindi i tasks) <strong>piuttosto che lavorare in modo seriale</strong>; perciò, la versione <strong>normale</strong> di chainCongruence() è preferibile. <img src="assets/cuboids%20table//EV.png" alt="Edges-Vertices"/> <img src="assets/cuboids%20table/FV.png" alt="Facets-Vertices"/></p><h3 id="Confronto-fra-chainCongruence()-normale-e-modificata"><a class="docs-heading-anchor" href="#Confronto-fra-chainCongruence()-normale-e-modificata">Confronto fra chainCongruence() normale e modificata</a><a id="Confronto-fra-chainCongruence()-normale-e-modificata-1"></a><a class="docs-heading-anchor-permalink" href="#Confronto-fra-chainCongruence()-normale-e-modificata" title="Permalink"></a></h3><p>Come anticipato nella presentazione dell&#39;esempio, ci si aspetterebbe un miglioramento, ma per via della semplicità della porzione di codice chiamata, risulta preferibile la versione normale. Tra l&#39;altro, anche l&#39;utilizzo di memoria è migliore nella versione normale: si passa da <strong>60.38 MiB</strong> della versione normale a <strong>75.98 MiB</strong> di quella modificata coi tasks; questo è dovuto alla porzione asincrona che richiede più risorse in parallelo. <img src="assets/cuboids%20table/AfterCongruence.png" alt="After congruence"/></p><ul><li>Versione normale:</li></ul><p><img src="assets/cuboids%20table/chainCongruenceNormal.png" alt="chainCongruence() Normale"/></p><ul><li>Versione modificata:</li></ul><p><img src="assets/cuboids%20table/chainCongruenceNormal.png" alt="chainCongruence() Modificata"/> &lt;br&gt;&lt;br&gt; Come per gli altri esempi, vengono mostrati ulteriori dettagli grafici: <img src="assets/cuboids%20table/Numbering.png" alt="Numbering"/> <img src="assets/cuboids%20table/Facets.png" alt="Explode Facets"/> <img src="assets/cuboids%20table/Edges.png" alt="Explode Edges"/> <img src="assets/cuboids%20table/Comp.png" alt="Decomposition"/></p><h1 id="Confronto-versioni-&quot;chainCongruence()-tra-le-varie-implementazioni&quot;"><a class="docs-heading-anchor" href="#Confronto-versioni-&quot;chainCongruence()-tra-le-varie-implementazioni&quot;">Confronto versioni &quot;chainCongruence() tra le varie implementazioni&quot;</a><a id="Confronto-versioni-&quot;chainCongruence()-tra-le-varie-implementazioni&quot;-1"></a><a class="docs-heading-anchor-permalink" href="#Confronto-versioni-&quot;chainCongruence()-tra-le-varie-implementazioni&quot;" title="Permalink"></a></h1><p>Sono stati utilizzati tre esempi, tutti diversi tra loro in quanto a dimensioni dell&#39;input, in modo da poter verificare i cambiamenti di comportamento delle funzioni al loro variare. Ci si aspetta dunque un miglioramento più evidente sugli esempi di dimensioni maggiore, questo perché eseguire operazioni complesse come quelle utilizzate per la programmazione asincrona e/o parallela, su input di piccole dimensioni, in modo controintuitivo, può penalizzare le prestazioni, cosa che non accade per input più grandi.</p><ol><li>Esempio 1 - input 3x24</li><li>Esempio 2 - input 3x432</li><li>Esempio 3 - input 1192x3</li></ol><p>La funzione testata e di cui si mostrano i confronti tra i diversi risultati nelle sezioni seguenti è <strong>&quot;chainCongruence()&quot;</strong>, nelle sue diverse versioni SM, GB, AA, eseguendo il confronto di ciascuna tra la versione originale del codice e quella ottimizzata introducento la parallelizzazione.</p><p>Per la valutazione delle prestazioni è stata utilizzata la macro julia <strong>@benchmark</strong>, presente all&#39;interno del package BenchmarkTools.jl, la quale va a eseguire la funzione testata un certo numero di volte, restituendo tempo medio di esecuzione (espresso in millisecondi o microsecondi) e lo spazio medio allocato (espresso in Mebibyte o Kibibyte), nei grafici seguenti vengono mostrati i tempi medi di esecuzione.</p><h1 id="Julia-Native-Sparse-Matrix"><a class="docs-heading-anchor" href="#Julia-Native-Sparse-Matrix">Julia Native Sparse Matrix</a><a id="Julia-Native-Sparse-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Native-Sparse-Matrix" title="Permalink"></a></h1><p>L&#39;implementazione SM non ha mostrato grandi miglioramenti; come detto in precedenza le differenze sono più evidenti nel terzo esempio in quanto è quello che presenta input di dimensioni maggiori. In questo esempio infatti si ha un miglioramento sui tempi di esecuzione di circa il 6%. <img src="../assets/SMdarkunica.png" alt="SM graph"/> </p><h1 id="GraphBLAS"><a class="docs-heading-anchor" href="#GraphBLAS">GraphBLAS</a><a id="GraphBLAS-1"></a><a class="docs-heading-anchor-permalink" href="#GraphBLAS" title="Permalink"></a></h1><p>L&#39;implementazione GB è stata quella che ha risposto meglio alle modifiche, con evidenti miglioramenti in tutti gli esempi testati. Si nota infatti un netto miglioramento del 65% sui tempi di esecuzione, questo perché la funzione &#39;cellCongruence()&#39; dell&#39;implementazione GB si presta bene all&#39;utilizzo dei threads. <img src="../assets/GBdarkunica.png" alt="GB graph"/> </p><h1 id="Array-of-Arrays"><a class="docs-heading-anchor" href="#Array-of-Arrays">Array of Arrays</a><a id="Array-of-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Array-of-Arrays" title="Permalink"></a></h1><p>Anche l&#39;implementazione AA ha ottenuto buoni risultati dopo le modifiche, si nota un miglioramento di quasi il 20% sui tempi di esecuzione del primo esempio e uno di circa il 5% sul terzo. <img src="../assets/AAdarkunica.png" alt="AA graph"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../documentazioni/arrayOfArrays/">« Array of Arrays</a><a class="docs-footer-nextpage" href="../authors/">Autori »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Tuesday 28 June 2022 11:02">Tuesday 28 June 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
